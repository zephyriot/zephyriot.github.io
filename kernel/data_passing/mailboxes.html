

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mailboxes &mdash; Zephyr Project Documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Zephyr Project Documentation" href="../../index.html"/>
        <link rel="up" title="Data Passing" href="data_passing.html"/>
        <link rel="next" title="Pipes" href="pipes.html"/>
        <link rel="prev" title="Message Queues" href="message_queues.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Zephyr Project
          

          
          </a>

          
            
            
              <div class="version">
                1.6.99
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../kernel.html">Zephyr Kernel Primer (version 2)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../overview/overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../threads/threads.html">Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../timing/timing.html">Timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memory/memory.html">Memory Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../synchronization/synchronization.html">Synchronization</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="data_passing.html">Data Passing</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fifos.html">Fifos</a></li>
<li class="toctree-l3"><a class="reference internal" href="lifos.html">Lifos</a></li>
<li class="toctree-l3"><a class="reference internal" href="stacks.html">Stacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="message_queues.html">Message Queues</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Mailboxes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concepts">Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#suggested-uses">Suggested Uses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-options">Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apis">APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pipes.html">Pipes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../other/other.html">Other Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../application/application.html">Application Development Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../porting/porting.html">Porting Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/drivers.html">Device Drivers and Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystems/subsystems.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/samples.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/kconfig/index.html">Configuration Options Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/code.html">Contributing Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSING.html">Licensing of Zephyr Project components</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Zephyr Project</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../kernel.html">Zephyr Kernel Primer (version 2)</a> &raquo;</li>
      
          <li><a href="data_passing.html">Data Passing</a> &raquo;</li>
      
    <li>Mailboxes</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/kernel/data_passing/mailboxes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mailboxes">
<span id="mailboxes-v2"></span><h1>Mailboxes</h1>
<p>A <em class="dfn">mailbox</em> is a kernel object that provides enhanced message queue
capabilities that go beyond the capabilities of a message queue object.
A mailbox allows threads to send and receive messages of any size
synchronously or asynchronously.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#concepts" id="id1">Concepts</a><ul>
<li><a class="reference internal" href="#message-format" id="id2">Message Format</a></li>
<li><a class="reference internal" href="#message-lifecycle" id="id3">Message Lifecycle</a></li>
<li><a class="reference internal" href="#thread-compatibility" id="id4">Thread Compatibility</a></li>
<li><a class="reference internal" href="#message-flow-control" id="id5">Message Flow Control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id6">Implementation</a><ul>
<li><a class="reference internal" href="#defining-a-mailbox" id="id7">Defining a Mailbox</a></li>
<li><a class="reference internal" href="#message-descriptors" id="id8">Message Descriptors</a></li>
<li><a class="reference internal" href="#sending-a-message" id="id9">Sending a Message</a></li>
<li><a class="reference internal" href="#receiving-a-message" id="id10">Receiving a Message</a></li>
</ul>
</li>
<li><a class="reference internal" href="#suggested-uses" id="id11">Suggested Uses</a></li>
<li><a class="reference internal" href="#configuration-options" id="id12">Configuration Options</a></li>
<li><a class="reference internal" href="#apis" id="id13">APIs</a></li>
</ul>
</div>
<div class="section" id="concepts">
<h2><a class="toc-backref" href="#id1">Concepts</a></h2>
<p>Any number of mailboxes can be defined. Each mailbox is referenced
by its memory address.</p>
<p>A mailbox has the following key properties:</p>
<ul class="simple">
<li>A <strong>send queue</strong> of messages that have been sent but not yet received.</li>
<li>A <strong>receive queue</strong> of threads that are waiting to receive a message.</li>
</ul>
<p>A mailbox must be initialized before it can be used. This sets both of its
queues to empty.</p>
<p>A mailbox allows threads, but not ISRs, to exchange messages.
A thread that sends a message is known as the <strong>sending thread</strong>,
while a thread that receives the message is known as the <strong>receiving thread</strong>.
Each message may be received by only one thread (i.e. point-to-multipoint and
broadcast messaging is not supported).</p>
<p>Messages exchanged using a mailbox are handled non-anonymously,
allowing both threads participating in an exchange to know
(and even specify) the identity of the other thread.</p>
<div class="section" id="message-format">
<h3><a class="toc-backref" href="#id2">Message Format</a></h3>
<p>A <strong>message descriptor</strong> is a data structure that specifies where a message&#8217;s
data is located, and how the message is to be handled by the mailbox.
Both the sending thread and the receiving thread supply a message descriptor
when accessing a mailbox. The mailbox uses the message descriptors to perform
a message exchange between compatible sending and receiving threads.
The mailbox also updates certain message descriptor fields during the exchange,
allowing both threads to know what has occurred.</p>
<p>A mailbox message contains zero or more bytes of <strong>message data</strong>.
The size and format of the message data is application-defined, and can vary
from one message to the next. There are two forms of message data:</p>
<ul class="simple">
<li>A <strong>message buffer</strong> is an area of memory provided by the thread
that sends or receives the message. An array or structure variable
can often be used for this purpose.</li>
<li>A <strong>message block</strong> is an area of memory allocated from a memory pool.</li>
</ul>
<p>A message may <em>not</em> have both a message buffer and a message block.
A message that has neither form of message data is called an <strong>empty message</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A message whose message buffer or memory block exists, but contains
zero bytes of actual data, is <em>not</em> an empty message.</p>
</div>
</div>
<div class="section" id="message-lifecycle">
<h3><a class="toc-backref" href="#id3">Message Lifecycle</a></h3>
<p>The life cycle of a message is straightforward. A message is created when
it is given to a mailbox by the sending thread. The message is then owned
by the mailbox until it is given to a receiving thread. The receiving thread
may retrieve the message data when it receives the message from the mailbox,
or it may perform data retrieval during a second, subsequent mailbox operation.
Only when data retrieval has occurred is the message deleted by the mailbox.</p>
</div>
<div class="section" id="thread-compatibility">
<h3><a class="toc-backref" href="#id4">Thread Compatibility</a></h3>
<p>A sending thread can specify the address of the thread to which the message
is sent, or it send it to any thread by specifying <code class="xref c c-macro docutils literal"><span class="pre">K_ANY</span></code>.
Likewise, a receiving thread can specify the address of the thread from which
it wishes to receive a message, or it can receive a message from any thread
by specifying <code class="xref c c-macro docutils literal"><span class="pre">K_ANY</span></code>.
A message is exchanged only when the requirements of both the sending thread
and receiving thread are satisfied; such threads are said to be <strong>compatible</strong>.</p>
<p>For example, if thread A sends a message to thread B (and only thread B)
it will be received by thread B if thread B tries to receive a message
from thread A or if thread B tries to receive from any thread.
The exchange will not occur if thread B tries to receive a message
from thread C. The message can never be received by thread C,
even if it tries to receive a message from thread A (or from any thread).</p>
</div>
<div class="section" id="message-flow-control">
<h3><a class="toc-backref" href="#id5">Message Flow Control</a></h3>
<p>Mailbox messages can be exchanged <strong>synchronously</strong> or <strong>asynchronously</strong>.
In a synchronous exchange, the sending thread blocks until the message
has been fully processed by the receiving thread. In an asynchronous exchange,
the sending thread does not wait until the message has been received
by another thread before continuing; this allows the sending thread to do
other work (such as gather data that will be used in the next message)
<em>before</em> the message is given to a receiving thread and fully processed.
The technique used for a given message exchange is determined
by the sending thread.</p>
<p>The synchronous exchange technique provides an implicit form of flow control,
preventing a sending thread from generating messages faster than they can be
consumed by receiving threads. The asynchronous exchange technique provides an
explicit form of flow control, which allows a sending thread to determine
if a previously sent message still exists before sending a subsequent message.</p>
</div>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id6">Implementation</a></h2>
<div class="section" id="defining-a-mailbox">
<h3><a class="toc-backref" href="#id7">Defining a Mailbox</a></h3>
<p>A mailbox is defined using a variable of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">k_mbox</span></code>.
It must then be initialized by calling <a class="reference internal" href="../../api/kernel_api.html#_CPPv211k_mbox_initP6k_mbox" title="k_mbox_init"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_init()</span></code></a>.</p>
<p>The following code defines and initializes an empty mailbox.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">k_mbox</span> <span class="n">my_mailbox</span><span class="p">;</span>

<span class="n">k_mbox_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively, a mailbox can be defined and initialized at compile time
by calling <a class="reference internal" href="../../api/kernel_api.html#c.K_MBOX_DEFINE" title="K_MBOX_DEFINE"><code class="xref c c-macro docutils literal"><span class="pre">K_MBOX_DEFINE</span></code></a>.</p>
<p>The following code has the same effect as the code segment above.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">K_MBOX_DEFINE</span><span class="p">(</span><span class="n">my_mailbox</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="message-descriptors">
<h3><a class="toc-backref" href="#id8">Message Descriptors</a></h3>
<p>A message descriptor is a structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">k_mbox_msg</span></code>.
Only the fields listed below should be used; any other fields are for
internal mailbox use only.</p>
<dl class="docutils">
<dt><em>info</em></dt>
<dd>A 32-bit value that is exchanged by the message sender and receiver,
and whose meaning is defined by the application. This exchange is
bi-directional, allowing the sender to pass a value to the receiver
during any message exchange, and allowing the receiver to pass a value
to the sender during a synchronous message exchange.</dd>
<dt><em>size</em></dt>
<dd>The message data size, in bytes. Set it to zero when sending an empty
message, or when sending a message buffer or message block with no
actual data. When receiving a message, set it to the maximum amount
of data desired, or to zero if the message data is not wanted.
The mailbox updates this field with the actual number of data bytes
exchanged once the message is received.</dd>
<dt><em>tx_data</em></dt>
<dd>A pointer to the sending thread&#8217;s message buffer. Set it to <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>
when sending a memory block, or when sending an empty message.
Leave this field uninitialized when receiving a message.</dd>
<dt><em>tx_block</em></dt>
<dd>The descriptor for the sending thread&#8217;s memory block. Set tx_block.pool_id
to <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code> when sending an empty message. Leave this field
uninitialized when sending a message buffer, or when receiving a message.</dd>
<dt><em>tx_target_thread</em></dt>
<dd>The address of the desired receiving thread. Set it to <code class="xref c c-macro docutils literal"><span class="pre">K_ANY</span></code>
to allow any thread to receive the message. Leave this field uninitialized
when receiving a message. The mailbox updates this field with
the actual receiver&#8217;s address once the message is received.</dd>
<dt><em>rx_source_thread</em></dt>
<dd>The address of the desired sending thread. Set it to <code class="xref c c-macro docutils literal"><span class="pre">K_ANY</span></code>
to receive a message sent by any thread. Leave this field uninitialized
when sending a message. The mailbox updates this field
with the actual sender&#8217;s address once the message is received.</dd>
</dl>
</div>
<div class="section" id="sending-a-message">
<h3><a class="toc-backref" href="#id9">Sending a Message</a></h3>
<p>A thread sends a message by first creating its message data, if any.
A message buffer is typically used when the data volume is small,
and the cost of copying the data is less than the cost of allocating
and freeing a message block.</p>
<p>Next, the sending thread creates a message descriptor that characterizes
the message to be sent, as described in the previous section.</p>
<p>Finally, the sending thread calls a mailbox send API to initiate the
message exchange. The message is immediately given to a compatible receiving
thread, if one is currently waiting. Otherwise, the message is added
to the mailbox&#8217;s send queue.</p>
<p>Any number of messages may exist simultaneously on a send queue.
The messages in the send queue are sorted according to the priority
of the sending thread. Messages of equal priority are sorted so that
the oldest message can be received first.</p>
<p>For a synchronous send operation, the operation normally completes when a
receiving thread has both received the message and retrieved the message data.
If the message is not received before the waiting period specified by the
sending thread is reached, the message is removed from the mailbox&#8217;s send queue
and the send operation fails. When a send operation completes successfully
the sending thread can examine the message descriptor to determine
which thread received the message, how much data was exchanged,
and the application-defined info value supplied by the receiving thread.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A synchronous send operation may block the sending thread indefinitely,
even when the thread specifies a maximum waiting period.
The waiting period only limits how long the mailbox waits
before the message is received by another thread. Once a message is received
there is <em>no</em> limit to the time the receiving thread may take to retrieve
the message data and unblock the sending thread.</p>
</div>
<p>For an asynchronous send operation, the operation always completes immediately.
This allows the sending thread to continue processing regardless of whether the
message is given to a receiving thread immediately or added to the send queue.
The sending thread may optionally specify a semaphore that the mailbox gives
when the message is deleted by the mailbox, for example, when the message
has been received and its data retrieved by a receiving thread.
The use of a semaphore allows the sending thread to easily implement
a flow control mechanism that ensures that the mailbox holds no more than
an application-specified number of messages from a sending thread
(or set of sending threads) at any point in time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A thread that sends a message asynchronously has no way to determine
which thread received the message, how much data was exchanged, or the
application-defined info value supplied by the receiving thread.</p>
</div>
<div class="section" id="sending-an-empty-message">
<h4>Sending an Empty Message</h4>
<p>This code uses a mailbox to synchronously pass 4 byte random values
to any consuming thread that wants one. The message &#8220;info&#8221; field is
large enough to carry the information being exchanged, so the data
portion of the message isn&#8217;t used.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">send_msg</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* generate random value to send */</span>
        <span class="kt">uint32_t</span> <span class="n">random_value</span> <span class="o">=</span> <span class="n">sys_rand32_get</span><span class="p">();</span>

        <span class="cm">/* prepare to send empty message */</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">random_value</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">.</span><span class="n">pool_id</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* send message and wait until a consumer receives it */</span>
        <span class="n">k_mbox_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sending-data-using-a-message-buffer">
<h4>Sending Data Using a Message Buffer</h4>
<p>This code uses a mailbox to synchronously pass variable-sized requests
from a producing thread to any consuming thread that wants it.
The message &#8220;info&#8221; field is used to exchange information about
the maximum size message buffer that each thread can handle.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">buffer_bytes_used</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">send_msg</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* generate data to send */</span>
        <span class="p">...</span>
        <span class="n">buffer_bytes_used</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">buffer_bytes_used</span><span class="p">);</span>

        <span class="cm">/* prepare to send message */</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">buffer_bytes_used</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">buffer_bytes_used</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_data</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* send message and wait until a consumer receives it */</span>
        <span class="n">k_mbox_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* info, size, and tx_target_thread fields have been updated */</span>

        <span class="cm">/* verify that message data was fully received */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">send_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">buffer_bytes_used</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;some message data dropped during transfer!&quot;</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;receiver only had room for %d bytes&quot;</span><span class="p">,</span> <span class="n">send_msg</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sending-data-using-a-message-block">
<h4>Sending Data Using a Message Block</h4>
<p>This code uses a mailbox to send asynchronous messages. A semaphore is used
to hold off the sending of a new message until the previous message
has been consumed, so that a backlog of messages doesn&#8217;t build up
when the consuming thread is unable to keep up.</p>
<p>The message data is stored in a memory block obtained from a memory pool,
thereby eliminating unneeded data copying when exchanging large messages.
The memory pool contains only two blocks: one block gets filled with
data while the previously sent block is being processed</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* define a semaphore, indicating that no message has been sent */</span>
<span class="n">K_SEM_DEFINE</span><span class="p">(</span><span class="n">my_sem</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/* define a memory pool containing 2 blocks of 4096 bytes */</span>
<span class="n">K_MEM_POOL_DEFINE</span><span class="p">(</span><span class="n">my_pool</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">send_msg</span><span class="p">;</span>

    <span class="k">volatile</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_buffer</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* allocate a memory block to hold the message data */</span>
        <span class="n">k_mem_pool_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp_pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* keep overwriting the hardware-generated data in the block    */</span>
        <span class="cm">/* until the previous message has been received by the consumer */</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">send_msg</span><span class="p">.</span><span class="n">tx_block</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">hw_buffer</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">k_sem_take</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_sem</span><span class="p">,</span> <span class="n">K_NO_WAIT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="cm">/* finish preparing to send message */</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
        <span class="n">send_msg</span><span class="p">.</span><span class="n">tx_target_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* send message containing most current data and loop around */</span>
        <span class="n">k_mbox_async_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_sem</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="receiving-a-message">
<h3><a class="toc-backref" href="#id10">Receiving a Message</a></h3>
<p>A thread receives a message by first creating a message descriptor that
characterizes the message it wants to receive. It then calls one of the
mailbox receive APIs. The mailbox searches its send queue and takes the message
from the first compatible thread it finds. If no compatible thread exists,
the receiving thread may choose to wait for one. If no compatible thread
appears before the waiting period specified by the receiving thread is reached,
the receive operation fails.
Once a receive operation completes successfully the receiving thread
can examine the message descriptor to determine which thread sent the message,
how much data was exchanged,
and the application-defined info value supplied by the sending thread.</p>
<p>Any number of receiving threads may wait simultaneously on a mailboxes&#8217;s
receive queue. The threads are sorted according to their priority;
threads of equal priority are sorted so that the one that started waiting
first can receive a message first.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Receiving threads do not always receive messages in a first in, first out
(FIFO) order, due to the thread compatibility constraints specified by the
message descriptors. For example, if thread A waits to receive a message
only from thread X and then thread B waits to receive a message from
thread Y, an incoming message from thread Y to any thread will be given
to thread B and thread A will continue to wait.</p>
</div>
<p>The receiving thread controls both the quantity of data it retrieves from an
incoming message and where the data ends up. The thread may choose to take
all of the data in the message, to take only the initial part of the data,
or to take no data at all. Similarly, the thread may choose to have the data
copied into a message buffer of its choice or to have it placed in a message
block. A message buffer is typically used when the volume of data
involved is small, and the cost of copying the data is less than the cost
of allocating and freeing a memory pool block.</p>
<p>The following sections outline various approaches a receiving thread may use
when retrieving message data.</p>
<div class="section" id="retrieving-data-at-receive-time">
<h4>Retrieving Data at Receive Time</h4>
<p>The most straightforward way for a thread to retrieve message data is to
specify a message buffer when the message is received. The thread indicates
both the location of the message buffer (which must not be <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>)
and its size.</p>
<p>The mailbox copies the message&#8217;s data to the message buffer as part of the
receive operation. If the message buffer is not big enough to contain all of the
message&#8217;s data, any uncopied data is lost. If the message is not big enough
to fill all of the buffer with data, the unused portion of the message buffer is
left unchanged. In all cases the mailbox updates the receiving thread&#8217;s
message descriptor to indicate how many data bytes were copied (if any).</p>
<p>The immediate data retrieval technique is best suited for small messages
where the maximum size of a message is known in advance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This technique can be used when the message data is actually located
in a memory block supplied by the sending thread. The mailbox copies
the data into the message buffer specified by the receiving thread, then
frees the meessage block back to its memory pool. This allows
a receiving thread to retrieve message data without having to know
whether the data was sent using a message buffer or a message block.</p>
</div>
<p>The following code uses a mailbox to process variable-sized requests from any
producing thread, using the immediate data retrieval technique. The message
&#8220;info&#8221; field is used to exchange information about the maximum size
message buffer that each thread can handle.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">recv_msg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">total</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* prepare to receive message */</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* get a data item, waiting as long as needed */</span>
        <span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* info, size, and rx_source_thread fields have been updated */</span>

        <span class="cm">/* verify that message data was fully received */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span> <span class="o">!=</span> <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;some message data dropped during transfer!&quot;</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sender tried to send %d bytes&quot;</span><span class="p">,</span> <span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* compute sum of all message bytes (from 0 to 100 of them) */</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="retrieving-data-later-using-a-message-buffer">
<h4>Retrieving Data Later Using a Message Buffer</h4>
<p>A receiving thread may choose to defer message data retrieval at the time
the message is received, so that it can retrieve the data into a message buffer
at a later time.
The thread does this by specifying a message buffer location of <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>
and a size indicating the maximum amount of data it is willing to retrieve
later.</p>
<p>The mailbox does not copy any message data as part of the receive operation.
However, the mailbox still updates the receiving thread&#8217;s message descriptor
to indicate how many data bytes are available for retrieval.</p>
<p>The receiving thread must then respond as follows:</p>
<ul class="simple">
<li>If the message descriptor size is zero, then either the sender&#8217;s message
contained no data or the receiving thread did not want to receive any data.
The receiving thread does not need to take any further action, since
the mailbox has already completed data retrieval and deleted the message.</li>
<li>If the message descriptor size is non-zero and the receiving thread still
wants to retrieve the data, the thread must call <a class="reference internal" href="../../api/kernel_api.html#_CPPv215k_mbox_data_getP10k_mbox_msgPv" title="k_mbox_data_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_data_get()</span></code></a>
and supply a message buffer large enough to hold the data. The mailbox copies
the data into the message buffer and deletes the message.</li>
<li>If the message descriptor size is non-zero and the receiving thread does <em>not</em>
want to retrieve the data, the thread must call <a class="reference internal" href="../../api/kernel_api.html#_CPPv215k_mbox_data_getP10k_mbox_msgPv" title="k_mbox_data_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_data_get()</span></code></a>.
and specify a message buffer of <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>. The mailbox deletes
the message without copying the data.</li>
</ul>
<p>The subsequent data retrieval technique is suitable for applications where
immediate retrieval of message data is undesirable. For example, it can be
used when memory limitations make it impractical for the receiving thread to
always supply a message buffer capable of holding the largest possible
incoming message.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This technique can be used when the message data is actually located
in a memory block supplied by the sending thread. The mailbox copies
the data into the message buffer specified by the receiving thread, then
frees the message block back to its memory pool. This allows
a receiving thread to retrieve message data without having to know
whether the data was sent using a message buffer or a message block.</p>
</div>
<p>The following code uses a mailbox&#8217;s deferred data retrieval mechanism
to get message data from a producing thread only if the message meets
certain criteria, thereby eliminating unneeded data copying. The message
&#8220;info&#8221; field supplied by the sender is used to classify the message.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">recv_msg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* prepare to receive message */</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* get message, but not its data */</span>
        <span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* get message data for only certain types of messages */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_message_type_ok</span><span class="p">(</span><span class="n">recv_msg</span><span class="p">.</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* retrieve message data and delete the message */</span>
            <span class="n">k_mbox_data_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

            <span class="cm">/* process data in &quot;buffer&quot; */</span>
            <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* ignore message data and delete the message */</span>
            <span class="n">k_mbox_data_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="retrieving-data-later-using-a-message-block">
<h4>Retrieving Data Later Using a Message Block</h4>
<p>A receiving thread may choose to retrieve message data into a memory block,
rather than a message buffer. This is done in much the same way as retrieving
data subsequently into a message buffer &#8212; the receiving thread first
receives the message without its data, then retrieves the data by calling
<a class="reference internal" href="../../api/kernel_api.html#_CPPv221k_mbox_data_block_getP10k_mbox_msgP10k_mem_poolP11k_mem_block7int32_t" title="k_mbox_data_block_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_data_block_get()</span></code></a>. The mailbox fills in the block descriptor
supplied by the receiving thread, allowing the thread to access the data.
The mailbox also deletes the received message, since data retrieval
has been completed. The receiving thread is then responsible for freeing
the message block back to the memory pool when the data is no longer needed.</p>
<p>This technique is best suited for applications where the message data has
been sent using a memory block.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This technique can be used when the message data is located in a message
buffer supplied by the sending thread. The mailbox automatically allocates
a memory block and copies the message data into it. However, this is much
less efficient than simply retrieving the data into a message buffer
supplied by the receiving thread. In addition, the receiving thread
must be designed to handle cases where the data retrieval operation fails
because the mailbox cannot allocate a suitable message block from the memory
pool. If such cases are possible, the receiving thread must either try
retrieving the data at a later time or instruct the mailbox to delete
the message without retrieving the data.</p>
</div>
<p>The following code uses a mailbox to receive messages sent using a memory block,
thereby eliminating unneeded data copying when processing a large message.
(The messages may be sent synchronously or asynchronously.)</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* define a memory pool containing 1 block of 10000 bytes */</span>
<span class="n">K_MEM_POOL_DEFINE</span><span class="p">(</span><span class="n">my_pool</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_mbox_msg</span> <span class="n">recv_msg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">k_mem_block</span> <span class="n">recv_block</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">total</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data_ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* prepare to receive message */</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
        <span class="n">recv_msg</span><span class="p">.</span><span class="n">rx_source_thread</span> <span class="o">=</span> <span class="n">K_ANY</span><span class="p">;</span>

        <span class="cm">/* get message, but not its data */</span>
        <span class="n">k_mbox_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_mailbox</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* get message data as a memory block and discard message */</span>
        <span class="n">k_mbox_data_block_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_block</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>

        <span class="cm">/* compute sum of all message bytes in memory block */</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">data_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">recv_block</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">recv_msg</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">data_ptr</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* release memory block containing data */</span>
        <span class="n">k_mem_pool_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_block</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An incoming message that was sent using a message buffer is also processed
correctly by this algorithm, since the mailbox automatically allocates
a memory block from the memory pool and fills it with the message data.
However, the performance benefit of using the memory block approach is lost.</p>
</div>
</div>
</div>
</div>
<div class="section" id="suggested-uses">
<h2><a class="toc-backref" href="#id11">Suggested Uses</a></h2>
<p>Use a mailbox to transfer data items between threads whenever the capabilities
of a message queue are insufficient.</p>
</div>
<div class="section" id="configuration-options">
<h2><a class="toc-backref" href="#id12">Configuration Options</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><a class="reference internal" href="../../reference/kconfig/CONFIG_NUM_MBOX_ASYNC_MSGS.html#cmdoption-arg-config-num-mbox-async-msgs"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_NUM_MBOX_ASYNC_MSGS</span></code></a></li>
</ul>
</div>
<div class="section" id="apis">
<h2><a class="toc-backref" href="#id13">APIs</a></h2>
<p>The following APIs for a mailbox are provided by <code class="file docutils literal"><span class="pre">kernel.h</span></code>:</p>
<ul class="simple">
<li><a class="reference internal" href="../../api/kernel_api.html#c.K_MBOX_DEFINE" title="K_MBOX_DEFINE"><code class="xref c c-macro docutils literal"><span class="pre">K_MBOX_DEFINE</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv211k_mbox_initP6k_mbox" title="k_mbox_init"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_init()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv210k_mbox_putP6k_mboxP10k_mbox_msg7int32_t" title="k_mbox_put"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_put()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv216k_mbox_async_putP6k_mboxP10k_mbox_msgP5k_sem" title="k_mbox_async_put"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_async_put()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv210k_mbox_getP6k_mboxP10k_mbox_msgPv7int32_t" title="k_mbox_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_get()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv215k_mbox_data_getP10k_mbox_msgPv" title="k_mbox_data_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_data_get()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv221k_mbox_data_block_getP10k_mbox_msgP10k_mem_poolP11k_mem_block7int32_t" title="k_mbox_data_block_get"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mbox_data_block_get()</span></code></a></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pipes.html" class="btn btn-neutral float-right" title="Pipes" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="message_queues.html" class="btn btn-neutral" title="Message Queues" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Intel Corporation, Wind River Systems, Inc.
      Last updated on Jan 26, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.6.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>