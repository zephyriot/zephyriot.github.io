

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Memory Pools &mdash; Zephyr Project Documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Zephyr Project Documentation" href="../../index.html"/>
        <link rel="up" title="Memory Allocation" href="memory.html"/>
        <link rel="next" title="Heap Memory Pool" href="heap.html"/>
        <link rel="prev" title="Memory Slabs" href="slabs.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Zephyr Project
          

          
          </a>

          
            
            
              <div class="version">
                1.6.99
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../kernel.html">Zephyr Kernel Primer (version 2)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../overview/overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../threads/threads.html">Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="../timing/timing.html">Timing</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="memory.html">Memory Allocation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="slabs.html">Memory Slabs</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory Pools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concepts">Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#suggested-uses">Suggested Uses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-options">Configuration Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apis">APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="heap.html">Heap Memory Pool</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../synchronization/synchronization.html">Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_passing/data_passing.html">Data Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../other/other.html">Other Services</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../application/application.html">Application Development Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../porting/porting.html">Porting Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/drivers.html">Device Drivers and Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystems/subsystems.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samples/samples.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/kconfig/index.html">Configuration Options Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/code.html">Contributing Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSING.html">Licensing of Zephyr Project components</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Zephyr Project</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../kernel.html">Zephyr Kernel Primer (version 2)</a> &raquo;</li>
      
          <li><a href="memory.html">Memory Allocation</a> &raquo;</li>
      
    <li>Memory Pools</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/kernel/memory/pools.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-pools">
<span id="memory-pools-v2"></span><h1>Memory Pools</h1>
<p>A <em class="dfn">memory pool</em> is a kernel object that allows memory blocks
to be dynamically allocated from a designated memory region.
The memory blocks in a memory pool can be of any size,
thereby reducing the amount of wasted memory when an application
needs to allocate storage for data structures of different sizes.
The memory pool uses a &#8220;buddy memory allocation&#8221; algorithm
to efficiently partition larger blocks into smaller ones,
allowing blocks of different sizes to be allocated and released efficiently
while limiting memory fragmentation concerns.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#concepts" id="id1">Concepts</a><ul>
<li><a class="reference internal" href="#internal-operation" id="id2">Internal Operation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="id3">Implementation</a><ul>
<li><a class="reference internal" href="#defining-a-memory-pool" id="id4">Defining a Memory Pool</a></li>
<li><a class="reference internal" href="#allocating-a-memory-block" id="id5">Allocating a Memory Block</a></li>
<li><a class="reference internal" href="#releasing-a-memory-block" id="id6">Releasing a Memory Block</a></li>
<li><a class="reference internal" href="#manually-defragmenting-a-memory-pool" id="id7">Manually Defragmenting a Memory Pool</a></li>
</ul>
</li>
<li><a class="reference internal" href="#suggested-uses" id="id8">Suggested Uses</a></li>
<li><a class="reference internal" href="#configuration-options" id="id9">Configuration Options</a></li>
<li><a class="reference internal" href="#apis" id="id10">APIs</a></li>
</ul>
</div>
<div class="section" id="concepts">
<h2><a class="toc-backref" href="#id1">Concepts</a></h2>
<p>Any number of memory pools can be defined. Each memory pool is referenced
by its memory address.</p>
<p>A memory pool has the following key properties:</p>
<ul class="simple">
<li>A <strong>minimum block size</strong>, measured in bytes.
It must be at least 4X bytes long, where X is greater than 0.</li>
<li>A <strong>maximum block size</strong>, measured in bytes.
This should be a power of 4 times larger than the minimum block size.
That is, &#8220;maximum block size&#8221; must equal &#8220;minimum block size&#8221; times 4^Y,
where Y is greater than or equal to zero.</li>
<li>The <strong>number of maximum-size blocks</strong> initially available.
This must be greater than zero.</li>
<li>A <strong>buffer</strong> that provides the memory for the memory pool&#8217;s blocks.
This must be at least &#8220;maximum block size&#8221; times
&#8220;number of maximum-size blocks&#8221; bytes long.</li>
</ul>
<p>The memory pool&#8217;s buffer must be aligned to an N-byte boundary, where
N is a power of 2 larger than 2 (i.e. 4, 8, 16, ...). To ensure that
all memory blocks in the buffer are similarly aligned to this boundary,
the minimum block size must also be a multiple of N.</p>
<p>A thread that needs to use a memory block simply allocates it from a memory
pool. Following a successful allocation, the <code class="xref c c-data docutils literal"><span class="pre">data</span></code> field
of the block descriptor supplied by the thread indicates the starting address
of the memory block. When the thread is finished with a memory block,
it must release the block back to the memory pool so the block can be reused.</p>
<p>If a block of the desired size is unavailable, a thread can optionally wait
for one to become available.
Any number of threads may wait on a memory pool simultaneously;
when a suitable memory block becomes available, it is given to
the highest-priority thread that has waited the longest.</p>
<p>Unlike a heap, more than one memory pool can be defined, if needed. For
example, different applications can utilize different memory pools; this
can help prevent one application from hijacking resources to allocate all
of the available blocks.</p>
<div class="section" id="internal-operation">
<h3><a class="toc-backref" href="#id2">Internal Operation</a></h3>
<p>A memory pool&#8217;s buffer is an array of maximum-size blocks,
with no wasted space between the blocks.
Each of these &#8220;level 0&#8221; blocks is a <em>quad-block</em> that can be
partitioned into four smaller &#8220;level 1&#8221; blocks of equal size, if needed.
Likewise, each level 1 block is itself a quad-block that can be partitioned
into four smaller &#8220;level 2&#8221; blocks in a similar way, and so on.
Thus, memory pool blocks can be recursively partitioned into quarters
until blocks of the minimum size are obtained,
at which point no further partitioning can occur.</p>
<p>A memory pool keeps track of how its buffer space has been partitioned
using an array of <em>block set</em> data structures. There is one block set
for each partitioning level supported by the pool, or (to put it another way)
for each block size. A block set keeps track of all free blocks of its
associated size using an array of <em>quad-block status</em> data structures.</p>
<p>When an application issues a request for a memory block,
the memory pool first determines the size of the smallest block
that will satisfy the request, and examines the corresponding block set.
If the block set contains a free block, the block is marked as used
and the allocation process is complete.
If the block set does not contain a free block,
the memory pool attempts to create one automatically by splitting a free block
of a larger size or by merging free blocks of smaller sizes;
if a suitable block can&#8217;t be created, the allocation request fails.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, memory pools will attempt to split a larger block
before trying to merge smaller blocks. However, they can also
be configured to merge smaller blocks first, or to skip
the merging step entirely. In the latter case, merging of smaller
blocks only occurs when the application explicitly issues
a request to defragment the entire memory pool.</p>
</div>
<p>The memory pool&#8217;s block merging and splitting process is done efficiently,
but it is a recursive algorithm that may incur significant overhead.
In addition, the merging algorithm cannot combine adjacent free blocks
of different sizes, nor can it merge adjacent free blocks of the same size
if they belong to different parent quad-blocks. As a consequence,
memory fragmentation issues can still be encountered when using a memory pool.</p>
<p>When an application releases a previously allocated memory block
it is simply marked as a free block in its associated block set.
The memory pool does not attempt to merge the newly freed block,
allowing it to be easily reallocated in its existing form.</p>
</div>
</div>
<div class="section" id="implementation">
<h2><a class="toc-backref" href="#id3">Implementation</a></h2>
<div class="section" id="defining-a-memory-pool">
<h3><a class="toc-backref" href="#id4">Defining a Memory Pool</a></h3>
<p>A memory pool is defined using a variable of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">k_mem_pool</span></code>.
However, since a memory pool also requires a number of variable-size data
structures to represent its block sets and the status of its quad-blocks,
the kernel does not support the run-time definition of a memory pool.
A memory pool can only be defined and initialized at compile time
by calling <a class="reference internal" href="../../api/kernel_api.html#c.K_MEM_POOL_DEFINE" title="K_MEM_POOL_DEFINE"><code class="xref c c-macro docutils literal"><span class="pre">K_MEM_POOL_DEFINE</span></code></a>.</p>
<p>The following code defines and initializes a memory pool that has 3 blocks
of 4096 bytes each, which can be partitioned into blocks as small as 64 bytes
and is aligned to a 4-byte boundary.
(That is, the memory pool supports block sizes of 4096, 1024, 256,
and 64 bytes.)
Observe that the macro defines all of the memory pool data structures,
as well as its buffer.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">K_MEM_POOL_DEFINE</span><span class="p">(</span><span class="n">my_pool</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="allocating-a-memory-block">
<h3><a class="toc-backref" href="#id5">Allocating a Memory Block</a></h3>
<p>A memory block is allocated by calling <a class="reference internal" href="../../api/kernel_api.html#_CPPv216k_mem_pool_allocP10k_mem_poolP11k_mem_block6size_t7int32_t" title="k_mem_pool_alloc"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mem_pool_alloc()</span></code></a>.</p>
<p>The following code builds on the example above, and waits up to 100 milliseconds
for a 200 byte memory block to become available, then fills it with zeroes.
A warning is issued if a suitable block is not obtained.</p>
<p>Note that the application will actually receive a 256 byte memory block,
since that is the closest matching size supported by the memory pool.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">k_mem_block</span> <span class="n">block</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">k_mem_pool_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory allocation time-out&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="releasing-a-memory-block">
<h3><a class="toc-backref" href="#id6">Releasing a Memory Block</a></h3>
<p>A memory block is released by calling <a class="reference internal" href="../../api/kernel_api.html#_CPPv215k_mem_pool_freeP11k_mem_block" title="k_mem_pool_free"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mem_pool_free()</span></code></a>.</p>
<p>The following code builds on the example above, and allocates a 75 byte
memory block, then releases it once it is no longer needed. (A 256 byte
memory block is actually used to satisfy the request.)</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">k_mem_block</span> <span class="n">block</span><span class="p">;</span>

<span class="n">k_mem_pool_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="n">K_FOREVER</span><span class="p">);</span>
<span class="p">...</span> <span class="cm">/* use memory block */</span>
<span class="n">k_mem_pool_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="manually-defragmenting-a-memory-pool">
<h3><a class="toc-backref" href="#id7">Manually Defragmenting a Memory Pool</a></h3>
<p>This code instructs the memory pool to concatenate unused memory blocks
into their parent quad-blocks wherever possible. Doing a full defragmentation
of the entire memory pool before allocating a number of memory blocks
may be more efficient than relying on the partial defragmentation that can
occur automatically each time a memory block allocation is requested.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">k_mem_pool_defragment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pool</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="suggested-uses">
<h2><a class="toc-backref" href="#id8">Suggested Uses</a></h2>
<p>Use a memory pool to allocate memory in variable-size blocks.</p>
<p>Use memory pool blocks when sending large amounts of data from one thread
to another, to avoid unnecessary copying of the data.</p>
</div>
<div class="section" id="configuration-options">
<h2><a class="toc-backref" href="#id9">Configuration Options</a></h2>
<p>Related configuration options:</p>
<ul class="simple">
<li><a class="reference internal" href="../../reference/kconfig/CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG.html#cmdoption-arg-config-mem-pool-split-before-defrag"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG</span></code></a></li>
<li><a class="reference internal" href="../../reference/kconfig/CONFIG_MEM_POOL_DEFRAG_BEFORE_SPLIT.html#cmdoption-arg-config-mem-pool-defrag-before-split"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_MEM_POOL_DEFRAG_BEFORE_SPLIT</span></code></a></li>
<li><a class="reference internal" href="../../reference/kconfig/CONFIG_MEM_POOL_SPLIT_ONLY.html#cmdoption-arg-config-mem-pool-split-only"><code class="xref std std-option docutils literal"><span class="pre">CONFIG_MEM_POOL_SPLIT_ONLY</span></code></a></li>
</ul>
</div>
<div class="section" id="apis">
<h2><a class="toc-backref" href="#id10">APIs</a></h2>
<p>The following memory pool APIs are provided by <code class="file docutils literal"><span class="pre">kernel.h</span></code>:</p>
<ul class="simple">
<li><a class="reference internal" href="../../api/kernel_api.html#c.K_MEM_POOL_DEFINE" title="K_MEM_POOL_DEFINE"><code class="xref c c-macro docutils literal"><span class="pre">K_MEM_POOL_DEFINE</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv216k_mem_pool_allocP10k_mem_poolP11k_mem_block6size_t7int32_t" title="k_mem_pool_alloc"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mem_pool_alloc()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv215k_mem_pool_freeP11k_mem_block" title="k_mem_pool_free"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mem_pool_free()</span></code></a></li>
<li><a class="reference internal" href="../../api/kernel_api.html#_CPPv217k_mem_pool_defragP10k_mem_pool" title="k_mem_pool_defrag"><code class="xref cpp cpp-func docutils literal"><span class="pre">k_mem_pool_defrag()</span></code></a></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="heap.html" class="btn btn-neutral float-right" title="Heap Memory Pool" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="slabs.html" class="btn btn-neutral" title="Memory Slabs" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Intel Corporation, Wind River Systems, Inc.
      Last updated on Jan 26, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.6.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>