

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Input / Output Driver APIs &mdash; Zephyr Project Documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Zephyr Project Documentation" href="../index.html"/>
        <link rel="up" title="API Documentation" href="api.html"/>
        <link rel="next" title="Power Management APIs" href="power_management_api.html"/>
        <link rel="prev" title="Device Driver Interface" href="device.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Zephyr Project
          

          
          </a>

          
            
            
              <div class="version">
                1.6.99
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel/kernel.html">Zephyr Kernel Primer (version 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../application/application.html">Application Development Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../porting/porting.html">Porting Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/drivers.html">Device Drivers and Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystems/subsystems.html">Subsystems</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="kernel_api.html">Kernel APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="device.html">Device Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="bluetooth.html">Bluetooth API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Input / Output Driver APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#adc-interface">ADC Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gpio-interface">GPIO Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i2c-interface">I2C Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ipm-interface">IPM Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pwm-interface">PWM Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pinmux-interface">Pinmux Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spi-interface">SPI Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#random-interface">Random Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart-interface">UART Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sensor-interface">Sensor Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="power_management_api.html">Power Management APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="file_system.html">File System APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../samples/samples.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/kconfig/index.html">Configuration Options Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/code.html">Contributing Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSING.html">Licensing of Zephyr Project components</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Zephyr Project</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="api.html">API Documentation</a> &raquo;</li>
      
    <li>Input / Output Driver APIs</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/io_interfaces.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="input-output-driver-apis">
<span id="io-interfaces"></span><h1>Input / Output Driver APIs</h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#adc-interface" id="id1">ADC Interface</a></li>
<li><a class="reference internal" href="#gpio-interface" id="id2">GPIO Interface</a></li>
<li><a class="reference internal" href="#i2c-interface" id="id3">I2C Interface</a></li>
<li><a class="reference internal" href="#ipm-interface" id="id4">IPM Interface</a></li>
<li><a class="reference internal" href="#pwm-interface" id="id5">PWM Interface</a></li>
<li><a class="reference internal" href="#pinmux-interface" id="id6">Pinmux Interface</a></li>
<li><a class="reference internal" href="#spi-interface" id="id7">SPI Interface</a></li>
<li><a class="reference internal" href="#random-interface" id="id8">Random Interface</a></li>
<li><a class="reference internal" href="#uart-interface" id="id9">UART Interface</a></li>
<li><a class="reference internal" href="#sensor-interface" id="id10">Sensor Interface</a></li>
</ul>
</div>
<div class="section" id="adc-interface">
<h2><a class="toc-backref" href="#contents">ADC Interface</a></h2>
<dl class="function">
<dt id="_CPPv210adc_enableP6device">
<span id="adc_enable__deviceP"></span><span class="target" id="Zephyrd7/d5e/group__adc__interface_1ga5230dcaa5529d509fa81c503b31eed6e"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">adc_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable ADC hardware. </p>
<p>This routine enables the ADC hardware block for data sampling for the specified device.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211adc_disableP6device">
<span id="adc_disable__deviceP"></span><span class="target" id="Zephyrd7/d5e/group__adc__interface_1ga933a4d03e43c561cd5cc51fe51744a10"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">adc_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable ADC hardware. </p>
<p>This routine disables the ADC hardware block for data sampling for the specified device.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28adc_readP6deviceP13adc_seq_table">
<span id="adc_read__deviceP.adc_seq_tableP"></span><span class="target" id="Zephyrd7/d5e/group__adc__interface_1ga6e2533ce0a132745be22922245b1e48b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">adc_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv213adc_seq_table" title="adc_seq_table">adc_seq_table</a> *<em>seq_table</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set a read request. </p>
<p>This routine sends a read or sampling request to the ADC hardware block. A sequence table describes the read request. The routine returns once the ADC completes the read sequence. The sample data can be retrieved from the memory buffers in the sequence table structure.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">seq_table</span></code>: Pointer to the structure representing the sequence table.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: On success </li>
<li><code class="docutils literal"><span class="pre">else</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv213adc_seq_entry">
<span id="adc_seq_entry"></span><span class="target" id="Zephyrd9/dbd/structadc__seq__entry"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">adc_seq_entry</code><br /></dt>
<dd><em>#include &lt;adc.h&gt;</em><p>ADC driver Sequence entry. </p>
<p>This structure defines a sequence entry used to define a sample from a specific channel. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv213adc_seq_table">
<span id="adc_seq_table"></span><span class="target" id="Zephyrd1/dab/structadc__seq__table"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">adc_seq_table</code><br /></dt>
<dd><em>#include &lt;adc.h&gt;</em><p>ADC driver Sequence table. </p>
<p>This structure defines a list of sequence entries used to execute a sequence of samplings. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv214adc_driver_api">
<span id="adc_driver_api"></span><span class="target" id="Zephyrd9/d4b/structadc__driver__api"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">adc_driver_api</code><br /></dt>
<dd><em>#include &lt;adc.h&gt;</em><p>ADC driver API. </p>
<p>This structure holds all API function pointers. </p>
</dd></dl>

</div>
<div class="section" id="gpio-interface">
<h2><a class="toc-backref" href="#contents">GPIO Interface</a></h2>
<dl class="type">
<dt id="_CPPv223gpio_callback_handler_t">
<span id="gpio_callback_handler_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga784b0b74389ce242bae33554b7b6d7bd"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">gpio_callback_handler_t</code><br /></dt>
<dd><p>Define the application callback handler function signature. </p>
<p>
Note: cb pointer can be used to retrieve private data through CONTAINER_OF() if original struct <a class="reference internal" href="#Zephyrd7/d96/structgpio__callback"><span class="std std-ref">gpio_callback</span></a> is stored in another private structure. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*port</span></code>: Device struct for the GPIO device. </li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_callback</span> <span class="pre">*cb</span></code>: Original struct <a class="reference internal" href="#Zephyrd7/d96/structgpio__callback"><span class="std std-ref">gpio_callback</span></a> owning this handler </li>
<li><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">pins</span></code>: Mask of pins that triggers the callback handler</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218gpio_pin_configureP6device7uint8_ti">
<span id="gpio_pin_configure__deviceP.uint8_t.i"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga8b1c2986eff15636575d2231f78e404a"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_pin_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint8_t <em>pin</em>, int <em>flags</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure a single pin. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pin</span></code>: Pin number to configure. </li>
<li><code class="docutils literal"><span class="pre">flags</span></code>: Flags for pin configuration. IN/OUT, interrupt ... </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214gpio_pin_writeP6device8uint32_t8uint32_t">
<span id="gpio_pin_write__deviceP.uint32_t.uint32_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga8b11317037787d91dda53e87069bdae1"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_pin_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t <em>pin</em>, uint32_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write the data value to a single pin. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pin</span></code>: Pin number where the data is written. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value set on the pin. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213gpio_pin_readP6device8uint32_tP8uint32_t">
<span id="gpio_pin_read__deviceP.uint32_t.uint32_tP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga35d27286f426829e64848ef6b9645b59"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_pin_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t <em>pin</em>, uint32_t *<em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read the data value of a single pin. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pin</span></code>: Pin number where data is read. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Integer pointer to receive the data values from the pin. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218gpio_init_callbackP13gpio_callback23gpio_callback_handler_t8uint32_t">
<span id="gpio_init_callback__gpio_callbackP.gpio_callback_handler_t.uint32_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaec9a797069f9337425ab5955d7a7641e"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">gpio_init_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#_CPPv213gpio_callback" title="gpio_callback">gpio_callback</a> *<em>callback</em>, <a class="reference internal" href="#_CPPv223gpio_callback_handler_t" title="gpio_callback_handler_t">gpio_callback_handler_t</a> <em>handler</em>, uint32_t <em>pin_mask</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper to initialize a struct <a class="reference internal" href="#Zephyrd7/d96/structgpio__callback"><span class="std std-ref">gpio_callback</span></a> properly. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">callback</span></code>: A valid Application&#8217;s callback structure pointer. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: A valid handler function pointer. </li>
<li><code class="docutils literal"><span class="pre">pin_mask</span></code>: A bit mask of relevant pins for the handler </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217gpio_add_callbackP6deviceP13gpio_callback">
<span id="gpio_add_callback__deviceP.gpio_callbackP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga1009a8d96b79d96d5b1a56c458adbf74"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_add_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv213gpio_callback" title="gpio_callback">gpio_callback</a> *<em>callback</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add an application callback. </p>
<p>
Note: enables to add as many callback as needed on the same port. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">callback</span></code>: A valid Application&#8217;s callback structure pointer. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220gpio_remove_callbackP6deviceP13gpio_callback">
<span id="gpio_remove_callback__deviceP.gpio_callbackP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga7e34d010a454359674ac412e40672a32"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_remove_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv213gpio_callback" title="gpio_callback">gpio_callback</a> *<em>callback</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Remove an application callback. </p>
<p>
Note: enables to remove as many callbacks as added through gpio_add_callback(). <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">callback</span></code>: A valid application&#8217;s callback structure pointer. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224gpio_pin_enable_callbackP6device8uint32_t">
<span id="gpio_pin_enable_callback__deviceP.uint32_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga0ff304e8c9a3fd6f7a0785992525b012"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_pin_enable_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t <em>pin</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable callback(s) for a single pin. </p>
<p>
Note: Depending on the driver implementation, this function will enable the pin to trigger an interruption. So as a semantic detail, if no callback is registered, of course none will be called. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pin</span></code>: Pin number where the callback function is enabled. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225gpio_pin_disable_callbackP6device8uint32_t">
<span id="gpio_pin_disable_callback__deviceP.uint32_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga6ac78dc5978c2dc8469d9af3900bde12"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_pin_disable_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t <em>pin</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable callback(s) for a single pin. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pin</span></code>: Pin number where the callback function is disabled. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219gpio_port_configureP6devicei">
<span id="gpio_port_configure__deviceP.i"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaf93ed696244afd77a0ca20fbca9b1be6"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_port_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, int <em>flags</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure all the pins the same way in the port. List out all flags on the detailed description. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">flags</span></code>: Flags for the port configuration. IN/OUT, interrupt ... </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215gpio_port_writeP6device8uint32_t">
<span id="gpio_port_write__deviceP.uint32_t"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga12fbb9f78ba736b0091b5fabcdf78923"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_port_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write a data value to the port. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to set on the port. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214gpio_port_readP6deviceP8uint32_t">
<span id="gpio_port_read__deviceP.uint32_tP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga15d3edc7d71ad3c69fb9352b52806972"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_port_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em>, uint32_t *<em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read data value from the port. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Integer pointer to receive the data value from the port. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225gpio_port_enable_callbackP6device">
<span id="gpio_port_enable_callback__deviceP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaa1c7e3c0b795d3c75514c62363d9a4ec"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_port_enable_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable callback(s) for the port. </p>
<p>
Note: Depending on the driver implementation, this function will enable the port to trigger an interruption on all pins, as long as these are configured properly. So as a semantic detail, if no callback is registered, of course none will be called. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv226gpio_port_disable_callbackP6device">
<span id="gpio_port_disable_callback__deviceP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga2e50ff0b05d4eea7b52fad37d0927dcf"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_port_disable_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>port</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable callback(s) for the port. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code on failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Pointer to the device structure for the driver instance. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220gpio_get_pending_intP6device">
<span id="gpio_get_pending_int__deviceP"></span><span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga7c5610653ba2cf00ce8a6a3b3a11e21e"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">gpio_get_pending_int</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Function to get pending interrupts. </p>
<p>The purpose of this function is to return the interrupt status register for the device. This is especially useful when waking up from low power states to check the wake up source.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">status</span></code>: != 0 if at least one gpio interrupt is pending. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: if no gpio interrupt is pending. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DIR_IN">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gadbc9e9d13a7d97e5f6c418a263f48944"></span><code class="descname">GPIO_DIR_IN</code></dt>
<dd><p>GPIO pin to be input. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DIR_OUT">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga4d2d9df24370e2c713c4362bb05e739e"></span><code class="descname">GPIO_DIR_OUT</code></dt>
<dd><p>GPIO pin to be output. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga30d5c0f4b2a4725ac8f2d14f8755da2b"></span><code class="descname">GPIO_INT</code></dt>
<dd><p>GPIO pin to trigger interrupt. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_ACTIVE_LOW">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaae9fc4ef6e31e2ffdd0a7aeca0755402"></span><code class="descname">GPIO_INT_ACTIVE_LOW</code></dt>
<dd><p>GPIO pin trigger on level low or falling edge. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_ACTIVE_HIGH">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga9b0f5886c272485443739efda8e22da4"></span><code class="descname">GPIO_INT_ACTIVE_HIGH</code></dt>
<dd><p>GPIO pin trigger on level high or rising edge. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_CLOCK_SYNC">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gae5a77cf4cefefe65c41f7dcbef079f5f"></span><code class="descname">GPIO_INT_CLOCK_SYNC</code></dt>
<dd><p>GPIO pin trigger to be synchronized to clock pulses. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_DEBOUNCE">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga2ca79acf34a8eb18f89f02f1edf8e8a6"></span><code class="descname">GPIO_INT_DEBOUNCE</code></dt>
<dd><p>Enable GPIO pin debounce. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_LEVEL">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga14d9aa8e2702a7da7c63d3bf15b08ac9"></span><code class="descname">GPIO_INT_LEVEL</code></dt>
<dd><p>Do Level trigger. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_EDGE">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga932b7980bb397e1361dadf45f683db4d"></span><code class="descname">GPIO_INT_EDGE</code></dt>
<dd><p>Do Edge trigger. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_INT_DOUBLE_EDGE">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga84cc92bc2cb53c4e9608f0bf0dbfa883"></span><code class="descname">GPIO_INT_DOUBLE_EDGE</code></dt>
<dd><p>Interrupt triggers on both rising and falling edge. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_POL_NORMAL">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga316bf1077818288d76fe741385a870a7"></span><code class="descname">GPIO_POL_NORMAL</code></dt>
<dd><p>GPIO pin polarity is normal. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_POL_INV">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga419ea80281d5eb40c7338c4f2f49d655"></span><code class="descname">GPIO_POL_INV</code></dt>
<dd><p>GPIO pin polarity is inverted. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_PUD_NORMAL">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaeafa00a3235f7e2d9416214bcafab0e3"></span><code class="descname">GPIO_PUD_NORMAL</code></dt>
<dd><p>GPIO pin to have no pull-up or pull-down. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_PUD_PULL_UP">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga8b0534eee4f8d382399e2d87b3ec0060"></span><code class="descname">GPIO_PUD_PULL_UP</code></dt>
<dd><p>Enable GPIO pin pull-up. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_PUD_PULL_DOWN">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gae375c65a33bf10d6da7385d7c9ff53fc"></span><code class="descname">GPIO_PUD_PULL_DOWN</code></dt>
<dd><p>Enable GPIO pin pull-down. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_PIN_ENABLE">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga0182c9d4ed6317b25825ff99896f4a46"></span><code class="descname">GPIO_PIN_ENABLE</code></dt>
<dd><p>Enable GPIO pin. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_PIN_DISABLE">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga6761b7e6c6f9845d1275e37be2f2cfa8"></span><code class="descname">GPIO_PIN_DISABLE</code></dt>
<dd><p>Disable GPIO pin. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_DFLT_LOW">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gad7fcda3168d06a040d3cda8450149feb"></span><code class="descname">GPIO_DS_DFLT_LOW</code></dt>
<dd><p>Default drive strength standard when GPIO pin output is low. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_ALT_LOW">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga2830a8b723d7db8335258eee0c5754b1"></span><code class="descname">GPIO_DS_ALT_LOW</code></dt>
<dd><p>Alternative drive strength when GPIO pin output is low. For hardware that does not support configurable drive strength use the default drive strength. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_DISCONNECT_LOW">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga994a501dc44775285379e57b639a4321"></span><code class="descname">GPIO_DS_DISCONNECT_LOW</code></dt>
<dd><p>Disconnect pin when GPIO pin output is low. For hardware that does not support disconnect use the default drive strength. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_DFLT_HIGH">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga58888cdec555b2e093be55347a9ae9a5"></span><code class="descname">GPIO_DS_DFLT_HIGH</code></dt>
<dd><p>Default drive strength when GPIO pin output is high. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_ALT_HIGH">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga119a2b2eee17fec97b5441ebff0b43b5"></span><code class="descname">GPIO_DS_ALT_HIGH</code></dt>
<dd><p>Alternative drive strength when GPIO pin output is high. For hardware that does not support configurable drive strengths use the default drive strength. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DS_DISCONNECT_HIGH">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gaf4f74face539d2772f7ee05e2e5ca978"></span><code class="descname">GPIO_DS_DISCONNECT_HIGH</code></dt>
<dd><p>Disconnect pin when GPIO pin output is high. For hardware that does not support disconnect use the default drive strength. </p>
</dd></dl>

<dl class="macro">
<dt id="c.GPIO_DECLARE_PIN_CONFIG_IDX">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga616de51664c228530bcbc040c4f65162"></span><code class="descname">GPIO_DECLARE_PIN_CONFIG_IDX</code><span class="sig-paren">(</span>_idx<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_DECLARE_PIN_CONFIG">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga7fa7c6401f82450aa7724748fce3d14e"></span><code class="descname">GPIO_DECLARE_PIN_CONFIG</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_PIN_IDX">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1gacd8ba19ab22cdc41129d5751059e17e7"></span><code class="descname">GPIO_PIN_IDX</code><span class="sig-paren">(</span>_idx, _controller, _pin<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_PIN">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga36cc99643833e040c4f8f9a3195be25f"></span><code class="descname">GPIO_PIN</code><span class="sig-paren">(</span>_controller, _pin<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_GET_CONTROLLER_IDX">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga9dd18b2ecd3d536d0bb48383f98caacb"></span><code class="descname">GPIO_GET_CONTROLLER_IDX</code><span class="sig-paren">(</span>_idx, _conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_GET_PIN_IDX">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga1c36ed55f22ef76e523101e2d2eaba2d"></span><code class="descname">GPIO_GET_PIN_IDX</code><span class="sig-paren">(</span>_idx, _conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_GET_CONTROLLER">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga6f389431c2cb547b583c5a5e4609cc6f"></span><code class="descname">GPIO_GET_CONTROLLER</code><span class="sig-paren">(</span>_conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.GPIO_GET_PIN">
<span class="target" id="Zephyrdc/d66/group__gpio__interface_1ga7ce304a7c0e1bd6845c51970ca507805"></span><code class="descname">GPIO_GET_PIN</code><span class="sig-paren">(</span>_conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv213gpio_callback">
<span id="gpio_callback"></span><span class="target" id="Zephyrd7/d96/structgpio__callback"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">gpio_callback</code><br /></dt>
<dd><em>#include &lt;gpio.h&gt;</em><p>GPIO callback structure. </p>
<p>Used to register a callback in the driver instance callback list. As many callbacks as needed can be added as long as each of them are unique pointers of struct <a class="reference internal" href="#Zephyrd7/d96/structgpio__callback"><span class="std std-ref">gpio_callback</span></a>. Beware such structure should not be allocated on stack.</p>
<p>Note: To help setting it, see gpio_init_callback() below </p>
</dd></dl>

</div>
<div class="section" id="i2c-interface">
<h2><a class="toc-backref" href="#contents">I2C Interface</a></h2>
<dl class="function">
<dt id="_CPPv213i2c_configureP6device8uint32_t">
<span id="i2c_configure__deviceP.uint32_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gafaedd39fab2308928598a2f8e15e4cb4"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>dev_config</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure operation of a host controller. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><a class="reference internal" href="#Zephyrd4/da5/uniondev__config"><span class="std std-ref"><span class="pre">dev_config</span></span></a></code>: Bit-packed 32-bit value to the device runtime configuration for the I2C controller.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29i2c_writeP6deviceP7uint8_t8uint32_t8uint16_t">
<span id="i2c_write__deviceP.uint8_tP.uint32_t.uint16_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga19a998428bfbef027c1c4667d030302b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t *<em>buf</em>, uint32_t <em>len</em>, uint16_t <em>addr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write a set amount of data to an I2C device. </p>
<p>This routine writes a set amount of data synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory pool from which the data is transferred. </li>
<li><code class="docutils literal"><span class="pre">len</span></code>: Size of the memory pool available for reading. </li>
<li><code class="docutils literal"><span class="pre">addr</span></code>: Address to the target I2C device for writing.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28i2c_readP6deviceP7uint8_t8uint32_t8uint16_t">
<span id="i2c_read__deviceP.uint8_tP.uint32_t.uint16_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga6a38549af53fcfbb0f0ee42071c66e34"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t *<em>buf</em>, uint32_t <em>len</em>, uint16_t <em>addr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read a set amount of data from an I2C device. </p>
<p>This routine reads a set amount of data synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory pool that stores the retrieved data. </li>
<li><code class="docutils literal"><span class="pre">len</span></code>: Size of the memory pool available for writing. </li>
<li><code class="docutils literal"><span class="pre">addr</span></code>: Address of the I2C device being read.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212i2c_transferP6deviceP7i2c_msg7uint8_t8uint16_t">
<span id="i2c_transfer__deviceP.i2c_msgP.uint8_t.uint16_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga703f49a57f658c1a896c4615df9327b6"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_transfer</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv27i2c_msg" title="i2c_msg">i2c_msg</a> *<em>msgs</em>, uint8_t <em>num_msgs</em>, uint16_t <em>addr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Perform data transfer to another I2C device. </p>
<p>This routine provides a generic interface to perform data transfer to another I2C device synchronously. Use i2c_read()/i2c_write() for simple read or write.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">msgs</span></code>: Array of messages to transfer. </li>
<li><code class="docutils literal"><span class="pre">num_msgs</span></code>: Number of messages to transfer. </li>
<li><code class="docutils literal"><span class="pre">addr</span></code>: Address of the I2C target device.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214i2c_burst_readP6device8uint16_t7uint8_tP7uint8_t7uint8_t">
<span id="i2c_burst_read__deviceP.uint16_t.uint8_t.uint8_tP.uint8_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga5b140b5461da4f2667a9bcb44207ba12"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_burst_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint16_t <em>dev_addr</em>, uint8_t <em>start_addr</em>, uint8_t *<em>buf</em>, uint8_t <em>num_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read multiple bytes from an internal address of an I2C device. </p>
<p>This routine reads multiple bytes from an internal address of an I2C device synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">dev_addr</span></code>: Address of the I2C device for reading. </li>
<li><code class="docutils literal"><span class="pre">start_addr</span></code>: Internal address from which the data is being read. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory pool that stores the retrieved data. </li>
<li><code class="docutils literal"><span class="pre">num_bytes</span></code>: Number of bytes being read.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215i2c_burst_writeP6device8uint16_t7uint8_tP7uint8_t7uint8_t">
<span id="i2c_burst_write__deviceP.uint16_t.uint8_t.uint8_tP.uint8_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga4cb06380b3ceebe34f3cc164c8f0395b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_burst_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint16_t <em>dev_addr</em>, uint8_t <em>start_addr</em>, uint8_t *<em>buf</em>, uint8_t <em>num_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write multiple bytes to an internal address of an I2C device. </p>
<p>This routine writes multiple bytes to an internal address of an I2C device synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">dev_addr</span></code>: Address of the I2C device for writing. </li>
<li><code class="docutils literal"><span class="pre">start_addr</span></code>: Internal address to which the data is being written. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory pool from which the data is transferred. </li>
<li><code class="docutils literal"><span class="pre">num_bytes</span></code>: Number of bytes being written.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217i2c_reg_read_byteP6device8uint16_t7uint8_tP7uint8_t">
<span id="i2c_reg_read_byte__deviceP.uint16_t.uint8_t.uint8_tP"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gac14fa848021c516187101bae77bdd8aa"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_reg_read_byte</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint16_t <em>dev_addr</em>, uint8_t <em>reg_addr</em>, uint8_t *<em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read internal register of an I2C device. </p>
<p>This routine reads the value of an 8-bit internal register of an I2C device synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">dev_addr</span></code>: Address of the I2C device for reading. </li>
<li><code class="docutils literal"><span class="pre">reg_addr</span></code>: Address of the internal register being read. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Memory pool that stores the retrieved register value.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218i2c_reg_write_byteP6device8uint16_t7uint8_t7uint8_t">
<span id="i2c_reg_write_byte__deviceP.uint16_t.uint8_t.uint8_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga1b18a10585da9800c152fa3c691df077"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_reg_write_byte</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint16_t <em>dev_addr</em>, uint8_t <em>reg_addr</em>, uint8_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write internal register of an I2C device. </p>
<p>This routine writes a value to an 8-bit internal register of an I2C device synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">dev_addr</span></code>: Address of the I2C device for writing. </li>
<li><code class="docutils literal"><span class="pre">reg_addr</span></code>: Address of the internal register being written. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to be written to internal register.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219i2c_reg_update_byteP6device7uint8_t7uint8_t7uint8_t7uint8_t">
<span id="i2c_reg_update_byte__deviceP.uint8_t.uint8_t.uint8_t.uint8_t"></span><span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga2a1973cce3f394f0c2654aefdcaceee0"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">i2c_reg_update_byte</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t <em>dev_addr</em>, uint8_t <em>reg_addr</em>, uint8_t <em>mask</em>, uint8_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Update internal register of an I2C device. </p>
<p>This routine updates the value of a set of bits from an 8-bit internal register of an I2C device synchronously.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">dev_addr</span></code>: Address of the I2C device for updating. </li>
<li><code class="docutils literal"><span class="pre">reg_addr</span></code>: Address of the internal register being updated. </li>
<li><code class="docutils literal"><span class="pre">mask</span></code>: Bitmask for updating internal register. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value for updating internal register.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_SPEED_STANDARD">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga5ca8c5fbb2caa99ab0b7007ce2c11633"></span><code class="descname">I2C_SPEED_STANDARD</code></dt>
<dd><p>I2C Standard Speed </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_SPEED_FAST">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gaef9d097ed2b58676498a33f3cf76f38d"></span><code class="descname">I2C_SPEED_FAST</code></dt>
<dd><p>I2C Fast Speed </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_SPEED_FAST_PLUS">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga9c867195c4a99615ed9c0011293a2155"></span><code class="descname">I2C_SPEED_FAST_PLUS</code></dt>
<dd><p>I2C Fast Plus Speed </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_SPEED_HIGH">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gac7bce1bbfb422a123d3228e97e2cbb71"></span><code class="descname">I2C_SPEED_HIGH</code></dt>
<dd><p>I2C High Speed </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_SPEED_ULTRA">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga213468d14d1241632c957873cf2d9628"></span><code class="descname">I2C_SPEED_ULTRA</code></dt>
<dd><p>I2C Ultra Fast Speed </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_ADDR_10_BITS">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga66836d37196ce866681f506c44c8766d"></span><code class="descname">I2C_ADDR_10_BITS</code></dt>
<dd><p>Use 10-bit addressing. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MODE_MASTER">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gaf5b67041f761d0c4b62d6827239418e2"></span><code class="descname">I2C_MODE_MASTER</code></dt>
<dd><p>Controller to act as Master. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MODE_SLAVE_READ">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gad18f948f2efafd6ed145bb1785d1fb8e"></span><code class="descname">I2C_MODE_SLAVE_READ</code></dt>
<dd><p>Controller to act as Slave. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MSG_WRITE">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gaf622d3c4aa1c832f90fff7200bb33732"></span><code class="descname">I2C_MSG_WRITE</code></dt>
<dd><p>Write message to I2C bus. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MSG_READ">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga6c3042e882e6a817a6498b7a4e1f0a95"></span><code class="descname">I2C_MSG_READ</code></dt>
<dd><p>Read message from I2C bus. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MSG_STOP">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gaad55262ad277ee60b786372c71f217aa"></span><code class="descname">I2C_MSG_STOP</code></dt>
<dd><p>Send STOP after this message. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_MSG_RESTART">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga8c6cf7be2a04979fdb9d0b7dd9c4f831"></span><code class="descname">I2C_MSG_RESTART</code></dt>
<dd><p>RESTART I2C transaction for this message. </p>
</dd></dl>

<dl class="macro">
<dt id="c.I2C_DECLARE_CLIENT_CONFIG">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga1ea3a529bda7d896262c97bf305641ac"></span><code class="descname">I2C_DECLARE_CLIENT_CONFIG</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.I2C_CLIENT">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga29d683222a96276b7aee09ddab034af7"></span><code class="descname">I2C_CLIENT</code><span class="sig-paren">(</span>_master, _addr<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.I2C_GET_MASTER">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1ga2b42e3f282659da16ae5a8a6e569e8d9"></span><code class="descname">I2C_GET_MASTER</code><span class="sig-paren">(</span>_conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.I2C_GET_ADDR">
<span class="target" id="Zephyrd0/d3a/group__i2c__interface_1gae26008d851b43232e04b32b1eb1c0dba"></span><code class="descname">I2C_GET_ADDR</code><span class="sig-paren">(</span>_conf<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv27i2c_msg">
<span id="i2c_msg"></span><span class="target" id="Zephyrd4/d5e/structi2c__msg"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">i2c_msg</code><br /></dt>
<dd><em>#include &lt;i2c.h&gt;</em><p>One I2C Message. </p>
<p>This defines one I2C message to transact on the I2C bus. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv210dev_config">
<span id="dev_config"></span><span class="target" id="Zephyrd4/da5/uniondev__config"></span><em class="property">union </em><code class="descclassname"></code><code class="descname">dev_config</code><br /></dt>
<dd><em>#include &lt;i2c.h&gt;</em><div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv2N10dev_config3rawE">
<span id="dev_config::raw__uint32_t"></span><span class="target" id="Zephyrd4/da5/uniondev__config_1ae83daabddbff5c550c95b708e067ec43"></span>uint32_t <code class="descname">raw</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv2N10dev_config4bitsE">
<span id="dev_config::bits__dev_config::__bits"></span><span class="target" id="Zephyrd4/da5/uniondev__config_1a024774f444deaa6300ed4bcc2479a34c"></span><em class="property">struct</em> <a class="reference internal" href="#_CPPv210dev_config" title="dev_config">dev_config</a>::__bits <code class="descname">bits</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="ipm-interface">
<h2><a class="toc-backref" href="#contents">IPM Interface</a></h2>
<dl class="type">
<dt id="_CPPv214ipm_callback_t">
<span id="ipm_callback_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gab67c812602a4c9632655c60b2389f049"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_callback_t</code><br /></dt>
<dd><p>Callback API for incoming IPM messages. </p>
<p>These callbacks execute in interrupt context. Therefore, use only interrupt-safe APIS. Registration of callbacks is done via <em>ipm_register_callback</em> </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">*context</span></code>: Arbitrary context pointer provided at registration time. </li>
<li><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code>: Message type identifier. </li>
<li><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">*data</span></code>: Message data pointer. The correct amount of data to read out must be inferred using the message id/upper level protocol. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv210ipm_send_t">
<span id="ipm_send_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1ga32bd7d09002dfd26358bc361c1ae6fed"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_send_t</code><br /></dt>
<dd><p>Callback API to send IPM messages. </p>
<p>See <em>ipm_send()</em> for argument definitions. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv223ipm_max_data_size_get_t">
<span id="ipm_max_data_size_get_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gab40fd48fc6a28a103e1849592cab9de7"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_max_data_size_get_t</code><br /></dt>
<dd><p>Callback API to get maximum data size. </p>
<p>See <em>ipm_max_data_size_get()</em> for argument definitions. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv220ipm_max_id_val_get_t">
<span id="ipm_max_id_val_get_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gabb1bb647e9df783bb8d4e9e55922eee0"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_max_id_val_get_t</code><br /></dt>
<dd><p>Callback API to get the ID&#8217;s maximum value. </p>
<p>See <em>ipm_max_id_val_get()</em> for argument definitions. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv223ipm_register_callback_t">
<span id="ipm_register_callback_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gabf88b05af7e12f87d59829d737c7bc96"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_register_callback_t</code><br /></dt>
<dd><p>Callback API upon registration. </p>
<p>See <em>ipm_register_callback()</em> for argument definitions. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv217ipm_set_enabled_t">
<span id="ipm_set_enabled_t"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1ga23e51d758ae8513a1ec17b1347c60889"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">ipm_set_enabled_t</code><br /></dt>
<dd><p>Callback API upon emablement of interrupts. </p>
<p>See <em>ipm_set_enabled()</em> for argument definitions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28ipm_sendP6devicei8uint32_tPKvi">
<span id="ipm_send__deviceP.i.uint32_t.voidCP.i"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1ga515ea70d66723cdf640e48d1ea7ef632"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">ipm_send</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>ipmdev</em>, int <em>wait</em>, uint32_t <em>id</em>, <em class="property">const</em> void *<em>data</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Try to send a message over the IPM device. </p>
<p>A message is considered consumed once the remote interrupt handler finishes. If there is deferred processing on the remote side, or if outgoing messages must be queued and wait on an event/semaphore, a high-level driver can implement that.</p>
<p>There are constraints on how much data can be sent or the maximum value of id. Use the <em>ipm_max_data_size_get</em> and <em>ipm_max_id_val_get</em> routines to determine them.</p>
<p>The <em>size</em> parameter is used only on the sending side to determine the amount of data to put in the message registers. It is not passed along to the receiving side. The upper-level protocol dictates the amount of data read back.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ipmdev</span></code>: Driver instance </li>
<li><code class="docutils literal"><span class="pre">wait</span></code>: If nonzero, busy-wait for remote to consume the message. The message is considered consumed once the remote interrupt handler finishes. If there is deferred processing on the remote side, or you would like to queue outgoing messages and wait on an event/semaphore, you can implement that in a high-level driver </li>
<li><code class="docutils literal"><span class="pre">id</span></code>: Message identifier. Values are constrained by <em>ipm_max_data_size_get</em> since many boards only allow for a subset of bits in a 32-bit register to store the ID. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Pointer to the data sent in the message. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Size of the data.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">EBUSY</span></code>: If the remote hasn&#8217;t yet read the last data sent. </li>
<li><code class="docutils literal"><span class="pre">EMSGSIZE</span></code>: If the supplied data size is unsupported by the driver. </li>
<li><code class="docutils literal"><span class="pre">EINVAL</span></code>: If there was a bad parameter, such as: too-large id value. or the device isn&#8217;t an outbound IPM channel. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: On success. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221ipm_register_callbackP6device14ipm_callback_tPv">
<span id="ipm_register_callback__deviceP.ipm_callback_t.voidP"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1ga90e5441d11fa10a3256d1efabb5f5198"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">ipm_register_callback</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>ipmdev</em>, <a class="reference internal" href="#_CPPv214ipm_callback_t" title="ipm_callback_t">ipm_callback_t</a> <em>cb</em>, void *<em>context</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Register a callback function for incoming messages. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ipmdev</span></code>: Driver instance pointer. </li>
<li><code class="docutils literal"><span class="pre">cb</span></code>: Callback function to execute on incoming message interrupts. </li>
<li><code class="docutils literal"><span class="pre">context</span></code>: Application-specific context pointer which will be passed to the callback function when executed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221ipm_max_data_size_getP6device">
<span id="ipm_max_data_size_get__deviceP"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gae7f8dea1bbf349160337bb7fd50b3672"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">ipm_max_data_size_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>ipmdev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return the maximum number of bytes possible in an outbound message. </p>
<p>IPM implementations vary on the amount of data that can be sent in a single message since the data payload is typically stored in registers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum possible size of a message in bytes. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ipmdev</span></code>: Driver instance pointer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218ipm_max_id_val_getP6device">
<span id="ipm_max_id_val_get__deviceP"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1ga446451acfdd47d364d475e4b655d5961"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">ipm_max_id_val_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>ipmdev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return the maximum id value possible in an outbound message. </p>
<p>Many IPM implementations store the message&#8217;s ID in a register with some bits reserved for other uses.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum possible value of a message ID. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ipmdev</span></code>: Driver instance pointer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215ipm_set_enabledP6devicei">
<span id="ipm_set_enabled__deviceP.i"></span><span class="target" id="Zephyrdf/d48/group__ipm__interface_1gabad348fc7db66bc8890fcf6c6a9a40f4"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">ipm_set_enabled</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>ipmdev</em>, int <em>enable</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable interrupts and callbacks for inbound channels. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ipmdev</span></code>: Driver instance pointer. </li>
<li><code class="docutils literal"><span class="pre">enable</span></code>: Set to 0 to disable and to nonzero to enable.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: On success. </li>
<li><code class="docutils literal"><span class="pre">EINVAL</span></code>: If it isn&#8217;t an inbound channel. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="pwm-interface">
<h2><a class="toc-backref" href="#contents">PWM Interface</a></h2>
<dl class="type">
<dt id="_CPPv212pwm_config_t">
<span id="pwm_config_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga2af1dce80bfbc01b9dd69255c6961a61"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_config_t</code><br /></dt>
<dd><p>Callback API upon configuration See <em>pwm_pin_configure()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv216pwm_set_values_t">
<span id="pwm_set_values_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga164e5d5f81e9e82ca9613e1004baf610"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_set_values_t</code><br /></dt>
<dd><p>Callback API upon setting PIN values See <em>pwm_pin_set_values()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv220pwm_set_duty_cycle_t">
<span id="pwm_set_duty_cycle_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gadeb47deaf711a162fcd0cda1fe75f2fc"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_set_duty_cycle_t</code><br /></dt>
<dd><p>Callback API upon setting the duty cycle See <em>pwm_pin_set_duty_cycle()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv215pwm_set_phase_t">
<span id="pwm_set_phase_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga3c96ee0d92e1ec565655fc5a9f359548"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_set_phase_t</code><br /></dt>
<dd><p>Callback API upon setting the phase See <em>pwm_pin_set_phase()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv216pwm_set_period_t">
<span id="pwm_set_period_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga2a1e71ef3170085a75909436cb16a23c"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_set_period_t</code><br /></dt>
<dd><p>Callback API upon setting the period See <em>pwm_pin_set_period()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv213pwm_pin_set_t">
<span id="pwm_pin_set_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gaf05244ed8ef69b3dea6814bebc969ab5"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_pin_set_t</code><br /></dt>
<dd><p>Callback API upon setting the pin See <em>pwm_pin_set_cycles()</em> for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv224pwm_get_cycles_per_sec_t">
<span id="pwm_get_cycles_per_sec_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gad562eb7428e4a61a0953ccdc105ec220"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pwm_get_cycles_per_sec_t</code><br /></dt>
<dd><p>Callback API upon getting cycles per second See <em>pwm_get_cycles_per_sec()</em> for argument description. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218pwm_pin_set_cyclesP6device8uint32_t8uint32_t8uint32_t">
<span id="pwm_pin_set_cycles__deviceP.uint32_t.uint32_t.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gaa15bef8aee8f7a2129195f4c76969a8e"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_cycles</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint32_t <em>period</em>, uint32_t <em>pulse</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the period and pulse width for a single PWM output. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM pin. </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Period (in clock cycle) set to the PWM. HW specific. </li>
<li><code class="docutils literal"><span class="pre">pulse</span></code>: Pulse width (in clock cycle) set to the PWM. HW specific.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216pwm_pin_set_usecP6device8uint32_t8uint32_t8uint32_t">
<span id="pwm_pin_set_usec__deviceP.uint32_t.uint32_t.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gaca25848c344138411e4ddb4d6b55b3b5"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_usec</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint32_t <em>period</em>, uint32_t <em>pulse</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the period and pulse width for a single PWM output. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM pin. </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Period (in micro second) set to the PWM. </li>
<li><code class="docutils literal"><span class="pre">pulse</span></code>: Pulse width (in micro second) set to the PWM.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222pwm_get_cycles_per_secP6device8uint32_tP8uint64_t">
<span id="pwm_get_cycles_per_sec__deviceP.uint32_t.uint64_tP"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga4f53911491cddb3315b9cc5608dbebbc"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_get_cycles_per_sec</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint64_t *<em>cycles</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the clock rate (cycles per second) for a single PWM output. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM pin. </li>
<li><code class="docutils literal"><span class="pre">cycles</span></code>: Pointer to the memory to store clock rate (cycles per sec). HW specific.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217pwm_pin_configureP6device7uint8_ti">
<span id="pwm_pin_configure__deviceP.uint8_t.i"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga7d56004f03ea84778d4a947bcc3b8fbe"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t <em>pwm</em>, int <em>flags</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure a single PWM output. </p>
<p></p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM output. </li>
<li><code class="docutils literal"><span class="pre">flags</span></code>: PWM configuration flags.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful, </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218pwm_pin_set_valuesP6device8uint32_t8uint32_t8uint32_t">
<span id="pwm_pin_set_values__deviceP.uint32_t.uint32_t.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga41c03195b7bb481a5d51941fe06b1963"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_values</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint32_t <em>on</em>, uint32_t <em>off</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the ON/OFF values for a single PWM output. </p>
<p></p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM output. </li>
<li><code class="docutils literal"><span class="pre">on</span></code>: ON value (number of timer count) set to the PWM. HW specific. How far from the beginning of a PWM cycle the PWM pulse starts. </li>
<li><code class="docutils literal"><span class="pre">off</span></code>: OFF value (number of timer count) set to the PWM. HW specific. How far from the beginning of a PWM cycle the PWM pulse stops.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218pwm_pin_set_periodP6device8uint32_t8uint32_t">
<span id="pwm_pin_set_period__deviceP.uint32_t.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga9c5ba1d4360f8297c9451345d2cf8ea2"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_period</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint32_t <em>period</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the period of a single PWM output. </p>
<p></p>
<p>It is optional to call this API. If not called, there is a default period.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM output. </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Period duration of the cycle to set in microseconds</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222pwm_pin_set_duty_cycleP6device8uint32_t7uint8_t">
<span id="pwm_pin_set_duty_cycle__deviceP.uint32_t.uint8_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga2171ac459de452e9874e1cb89310a365"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_duty_cycle</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint8_t <em>duty</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the duty cycle of a single PWM output. </p>
<p></p>
<p>This routine overrides any ON/OFF values set before.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM output. </li>
<li><code class="docutils literal"><span class="pre">duty</span></code>: Duty cycle to set to the PWM in %, for example, 50 sets to 50%.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217pwm_pin_set_phaseP6device8uint32_t7uint8_t">
<span id="pwm_pin_set_phase__deviceP.uint32_t.uint8_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gaad49a304ee9e29466d450aa5862cfe30"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_pin_set_phase</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pwm</em>, uint8_t <em>phase</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the phase of a single PWM output. </p>
<p></p>
<p>This routine sets the delay before pulses.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">pwm</span></code>: PWM output. </li>
<li><code class="docutils literal"><span class="pre">phase</span></code>: The number of clock ticks to delay before the start of pulses.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217pwm_all_configureP6devicei">
<span id="pwm_all_configure__deviceP.i"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1gae64f0f65a6f389cdda2b3afca734600b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_all_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, int <em>flags</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure all the PWM outputs. </p>
<p></p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">flags</span></code>: PWM configuration flags.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218pwm_all_set_valuesP6device8uint32_t8uint32_t">
<span id="pwm_all_set_values__deviceP.uint32_t.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga31a908ac97bd83c32d0a814f061e1ac1"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_all_set_values</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>on</em>, uint32_t <em>off</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the ON/OFF values for all PWM outputs. </p>
<p></p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">on</span></code>: ON value (number of timer count) set to the PWM. HW specific. How far from the beginning of a PWM cycle the PWM pulse starts. </li>
<li><code class="docutils literal"><span class="pre">off</span></code>: OFF value (number of timer count) set to the PWM. HW specific. How far from the beginning of a PWM cycle the PWM pulse stops.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214pwm_all_periodP6device8uint32_t">
<span id="pwm_all_period__deviceP.uint32_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga4ca5f05ecc0acdd2b8a8374171904741"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_all_period</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>period</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the period of all PWM outputs. </p>
<p></p>
<p>It is optional to call this API. If not called, there is a default period.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Period duration of the cycle to set in microseconds</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222pwm_all_set_duty_cycleP6device7uint8_t">
<span id="pwm_all_set_duty_cycle__deviceP.uint8_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga2139d17c1b62e66f8383df0604e7bb71"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_all_set_duty_cycle</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t <em>duty</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the duty cycle of all PWM outputs. </p>
<p></p>
<p>This overrides any ON/OFF values being set before.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">duty</span></code>: Duty cycle to set to the PWM in %, for example, 50 sets to 50%.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217pwm_all_set_phaseP6device7uint8_t">
<span id="pwm_all_set_phase__deviceP.uint8_t"></span><span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga592818e332fca2508020feddbbc7d7e5"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pwm_all_set_phase</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t <em>phase</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the phase of all PWM outputs. </p>
<p></p>
<p>This routine sets the delay before pulses.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">phase</span></code>: The number of clock ticks to delay before the start of pulses.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.PWM_ACCESS_BY_PIN">
<span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga98ae4878041b5f44a161c48e564c849a"></span><code class="descname">PWM_ACCESS_BY_PIN</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PWM_ACCESS_ALL">
<span class="target" id="Zephyrd5/d05/group__pwm__interface_1ga941e0163f9278a550c963fab1e588f82"></span><code class="descname">PWM_ACCESS_ALL</code></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv214pwm_driver_api">
<span id="pwm_driver_api"></span><span class="target" id="Zephyrd9/d02/structpwm__driver__api"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">pwm_driver_api</code><br /></dt>
<dd><em>#include &lt;pwm.h&gt;</em><p>PWM driver API definition. </p>
</dd></dl>

</div>
<div class="section" id="pinmux-interface">
<h2><a class="toc-backref" href="#contents">Pinmux Interface</a></h2>
<dl class="type">
<dt id="_CPPv28pmux_set">
<span id="pmux_set"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga7b1844d8e2549218d93a85ba135df600"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pmux_set</code><br /></dt>
<dd><p>Callback API upon setting a PIN&#8217;s function See pinmux_pin_set() for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv28pmux_get">
<span id="pmux_get"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gac5ffb9c41ad977e43019ad45be384e09"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pmux_get</code><br /></dt>
<dd><p>Callback API upon getting a PIN&#8217;s function See pinmux_pin_get() for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv211pmux_pullup">
<span id="pmux_pullup"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga64bd26e4d7a2c13201982c91e375b7d2"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pmux_pullup</code><br /></dt>
<dd><p>Callback API upon setting a PIN&#8217;s pullup See pinmix_pin_pullup() for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv210pmux_input">
<span id="pmux_input"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga583c9d6cf16d11297343f982a07e18f2"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">pmux_input</code><br /></dt>
<dd><p>Callback API upon setting a PIN&#8217;s input function See pinmux_input() for argument description. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214pinmux_pin_setP6device8uint32_t8uint32_t">
<span id="pinmux_pin_set__deviceP.uint32_t.uint32_t"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga1dd7862b0535c88451c7098051c2222d"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pinmux_pin_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pin</em>, uint32_t <em>func</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv214pinmux_pin_getP6device8uint32_tP8uint32_t">
<span id="pinmux_pin_get__deviceP.uint32_t.uint32_tP"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gaab79c7c63d9bd3df4fa6f5db19e0f019"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pinmux_pin_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pin</em>, uint32_t *<em>func</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv217pinmux_pin_pullupP6device8uint32_t7uint8_t">
<span id="pinmux_pin_pullup__deviceP.uint32_t.uint8_t"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga77d7150edca9484b6acd8b52707d7bc3"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pinmux_pin_pullup</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pin</em>, uint8_t <em>func</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv223pinmux_pin_input_enableP6device8uint32_t7uint8_t">
<span id="pinmux_pin_input_enable__deviceP.uint32_t.uint8_t"></span><span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga7e845f013a2fabcbdd71331c38133b90"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">pinmux_pin_input_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>pin</em>, uint8_t <em>func</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_FUNC_A">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga98cfa6f81cd2d924b4b8410cc58dcced"></span><code class="descname">PINMUX_FUNC_A</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_FUNC_B">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga1f94697f2a9f866e751fad5fa50ac54a"></span><code class="descname">PINMUX_FUNC_B</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_FUNC_C">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gad65d0f30a98080f3e21e2db0d6f63e90"></span><code class="descname">PINMUX_FUNC_C</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_FUNC_D">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gabcab76c799f9fefa55d8814c820f212a"></span><code class="descname">PINMUX_FUNC_D</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_PULLUP_ENABLE">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga8dc656edabddd2ce6235734929ca286d"></span><code class="descname">PINMUX_PULLUP_ENABLE</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_PULLUP_DISABLE">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gade55cf3295ee85713135cb9ac8d65172"></span><code class="descname">PINMUX_PULLUP_DISABLE</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_INPUT_ENABLED">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1ga5069cd0df03a8b025bb450cfbc68ec9d"></span><code class="descname">PINMUX_INPUT_ENABLED</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.PINMUX_OUTPUT_ENABLED">
<span class="target" id="Zephyrd2/d10/group__pinmux__interface_1gac7b6ef9a7d226dcacc308225a74da3f7"></span><code class="descname">PINMUX_OUTPUT_ENABLED</code></dt>
<dd></dd></dl>

</div>
<div class="section" id="spi-interface">
<h2><a class="toc-backref" href="#contents">SPI Interface</a></h2>
<dl class="type">
<dt id="_CPPv217spi_api_configure">
<span id="spi_api_configure"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1gacae0117f1a1c03bb84d281092bd3ce80"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">spi_api_configure</code><br /></dt>
<dd><p>Callback API upon configuring the const controller See spi_configure() for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv220spi_api_slave_select">
<span id="spi_api_slave_select"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1gafc6a1804a67fe9a605508fcfa39f8531"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">spi_api_slave_select</code><br /></dt>
<dd><p>Callback API upon selecting a slave See spi_slave_select() for argument description. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv210spi_api_io">
<span id="spi_api_io"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1ga289edfc270554093f36a65dd85118a21"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">spi_api_io</code><br /></dt>
<dd><p>Callback API for I/O See spi_read() and spi_write() for argument descriptions. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213spi_configureP6deviceP10spi_config">
<span id="spi_configure__deviceP.spi_configP"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1gacce6bda73cd1cc1af969dbbf77e4881c"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">spi_configure</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv210spi_config" title="spi_config">spi_config</a> *<em>config</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Configure a host controller for operating against slaves. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">config</span></code>: Pointer to the configuration provided by the application.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216spi_slave_selectP6device8uint32_t">
<span id="spi_slave_select__deviceP.uint32_t"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1gad6cf34667635195ae04cdac197a25706"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">spi_slave_select</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>slave</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Select a slave to deal with. </p>
<p>This routine is meaningful only if the controller supports per-slave addressing: One SS line per-slave. If not, this routine has no effect and daisy-chaining should be considered to deal with multiple slaves on the same line.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance </li>
<li><code class="docutils literal"><span class="pre">slave</span></code>: An integer identifying the slave. It starts from 1 which corresponds to cs0.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28spi_readP6devicePv8uint32_t">
<span id="spi_read__deviceP.voidP.uint32_t"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1gadcf9c5875fc37cd3798bb3ae313ac6b4"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">spi_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, void *<em>buf</em>, uint32_t <em>len</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read the specified amount of data from the SPI driver. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory buffer where data will be transferred. </li>
<li><code class="docutils literal"><span class="pre">len</span></code>: Size of the memory buffer available for writing.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29spi_writeP6devicePKv8uint32_t">
<span id="spi_write__deviceP.voidCP.uint32_t"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1ga72aaf518723b5cb526cf927fd5801862"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">spi_write</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> void *<em>buf</em>, uint32_t <em>len</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write the specified amount of data from the SPI driver. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">buf</span></code>: Memory buffer from where data is transferred. </li>
<li><code class="docutils literal"><span class="pre">len</span></code>: Size of the memory buffer available for reading.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214spi_transceiveP6devicePKv8uint32_tPv8uint32_t">
<span id="spi_transceive__deviceP.voidCP.uint32_t.voidP.uint32_t"></span><span class="target" id="Zephyrde/df9/group__spi__interface_1ga947228340ac649873689b1494d104f0c"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">spi_transceive</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> void *<em>tx_buf</em>, uint32_t <em>tx_buf_len</em>, void *<em>rx_buf</em>, uint32_t <em>rx_buf_len</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read and write the specified amount of data from the SPI driver. </p>
<p>This routine is meant for full-duplex transmission. Only equal length is supported(tx_buf_len must be equal to rx_buf_len).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the device structure for the driver instance. </li>
<li><code class="docutils literal"><span class="pre">tx_buf</span></code>: Memory buffer where data originates </li>
<li><code class="docutils literal"><span class="pre">tx_buf_len</span></code>: Size of the memory buffer available for reading. </li>
<li><code class="docutils literal"><span class="pre">rx_buf</span></code>: Memory buffer where data is transferred. </li>
<li><code class="docutils literal"><span class="pre">rx_buf_len</span></code>: Size of the memory buffer available for writing.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">Negative</span></code>: errno code if failure. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SPI_MODE_CPOL">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga5a2be1003873beaa0ade10e7218d67d5"></span><code class="descname">SPI_MODE_CPOL</code></dt>
<dd><p>SPI Polarity &amp; Phase Modes. </p>
</dd></dl>

<dl class="macro">
<dt id="c.SPI_MODE_CPHA">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga35e98b37e3ec4889a90100abe884590f"></span><code class="descname">SPI_MODE_CPHA</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_MODE_LOOP">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga8619b297de563eca6852af34c79daa62"></span><code class="descname">SPI_MODE_LOOP</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_MODE_MASK">
<span class="target" id="Zephyrde/df9/group__spi__interface_1gaa64ece5364d0d7e1226d50e8773ab654"></span><code class="descname">SPI_MODE_MASK</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_MODE">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga27ede83637d8adc8a34573fcbda631e5"></span><code class="descname">SPI_MODE</code><span class="sig-paren">(</span>_in_<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_TRANSFER_MSB">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga7761f42c6241cf396fc02d0de8617e46"></span><code class="descname">SPI_TRANSFER_MSB</code></dt>
<dd><p>SPI Transfer modes (host controller dependent) </p>
</dd></dl>

<dl class="macro">
<dt id="c.SPI_TRANSFER_LSB">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga93504a76a265bedbe781c107beebc9dc"></span><code class="descname">SPI_TRANSFER_LSB</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_TRANSFER_MASK">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga73a4d7a53c0868955675cec4f9bcfe78"></span><code class="descname">SPI_TRANSFER_MASK</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_WORD_SIZE_MASK">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga77146b5c9ce71c3a8352b5026f77cda6"></span><code class="descname">SPI_WORD_SIZE_MASK</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_WORD_SIZE_GET">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga0219cd9c5cc5fd26ef50619b7fdfd57e"></span><code class="descname">SPI_WORD_SIZE_GET</code><span class="sig-paren">(</span>_in_<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.SPI_WORD">
<span class="target" id="Zephyrde/df9/group__spi__interface_1ga40d18e75a6d5990f1c8d7432274f8c16"></span><code class="descname">SPI_WORD</code><span class="sig-paren">(</span>_in_<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="class">
<dt id="_CPPv210spi_config">
<span id="spi_config"></span><span class="target" id="Zephyrd1/d27/structspi__config"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">spi_config</code><br /></dt>
<dd><em>#include &lt;spi.h&gt;</em><p>SPI configuration structure. </p>
<p>config is a bit field with the following parts: mode [ 0 : 2 ] - Polarity, phase and loop mode. transfer_mode [ 3 ] - LSB or MSB first transfer mode. word_size [ 4 : 11 ] - Size of a data frame in bits. RESERVED [ 12 : 31 ] - Undefined or device-specific usage.</p>
<p>max_sys_freq is the clock divider supported by the the host spi controller. </p>
</dd></dl>

</div>
<div class="section" id="random-interface">
<h2><a class="toc-backref" href="#contents">Random Interface</a></h2>
<dl class="type">
<dt id="_CPPv220random_get_entropy_t">
<span id="random_get_entropy_t"></span><span class="target" id="Zephyrdd/dcd/group__random__interface_1ga9a70e00ea93c4f4ff586e7d082217d10"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">random_get_entropy_t</code><br /></dt>
<dd><p>Callback API to get entropy. </p>
<p>See random_get_entropy() for argument description </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218random_get_entropyP6deviceP7uint8_t8uint16_t">
<span id="random_get_entropy__deviceP.uint8_tP.uint16_t"></span><span class="target" id="Zephyrdd/dcd/group__random__interface_1ga0e1055ccbd91bbf5111670666382013f"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">random_get_entropy</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t *<em>buffer</em>, uint16_t <em>length</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get entropy from the random driver. </p>
<p>Fill a buffer with entropy from the random driver.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the random device. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Buffer to fill with entropy. </li>
<li><code class="docutils literal"><span class="pre">length</span></code>: Buffer length. </li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: on success. </li>
<li><code class="docutils literal"><span class="pre">-ERRNO</span></code>: errno code on error. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="uart-interface">
<h2><a class="toc-backref" href="#contents">UART Interface</a></h2>
<dl class="type">
<dt id="_CPPv219uart_irq_callback_t">
<span id="uart_irq_callback_t"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga0aa1f3cb1fc58f27be5bd3c2efe27064"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">uart_irq_callback_t</code><br /></dt>
<dd><p>Define the application callback function signature for UART. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Device struct for the UART device. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv222uart_irq_config_func_t">
<span id="uart_irq_config_func_t"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga35b4204a6645cc6aff8386b6ea678eff"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">uart_irq_config_func_t</code><br /></dt>
<dd><p>For configuring IRQ on each individual UART device. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214uart_err_checkP6device">
<span id="uart_err_check__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga5d739890a2ee39c90dad76fa770aaf9b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_err_check</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check whether an error was detected. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">UART_ERROR_OVERRUN</span></code>: if an overrun error was detected. </li>
<li><code class="docutils literal"><span class="pre">UART_ERROR_PARITY</span></code>: if a parity error was detected. </li>
<li><code class="docutils literal"><span class="pre">UART_ERROR_FRAMING</span></code>: if a framing error was detected. </li>
<li><code class="docutils literal"><span class="pre">UART_ERROR_BREAK</span></code>: if a break error was detected. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212uart_poll_inP6devicePh">
<span id="uart_poll_in__deviceP.unsigned-cP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga55b0409438d7c33a50655191c132ae28"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_poll_in</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, unsigned char *<em>p_char</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Poll the device for input. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">p_char</span></code>: Pointer to character.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If a character arrived. </li>
<li><code class="docutils literal"><span class="pre">-1</span></code>: If no character was available to read (i.e., the UART input buffer was empty). </li>
<li><code class="docutils literal"><span class="pre">-ENOTSUP</span></code>: If the operation is not supported. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213uart_poll_outP6deviceh">
<span id="uart_poll_out__deviceP.unsigned-c"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga0f98dacdcd7441db0adddbcc33744cd7"></span><em class="property">static</em> unsigned char <code class="descclassname"></code><code class="descname">uart_poll_out</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, unsigned char <em>out_char</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Output a character in polled mode. </p>
<p>This routine checks if the transmitter is empty. When the transmitter is empty, it writes a character to the data register.</p>
<p>To send a character when hardware flow control is enabled, the handshake signal CTS must be asserted.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">out_char</span></code>: Character to send.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">char</span></code>: Sent character. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214uart_fifo_fillP6devicePK7uint8_ti">
<span id="uart_fifo_fill__deviceP.uint8_tCP.i"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga116367c661b6c611e2267b66e7ea9d62"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_fifo_fill</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">const</em> uint8_t *<em>tx_data</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Fill FIFO with data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes sent. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">tx_data</span></code>: Data to transmit. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Number of bytes to send.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214uart_fifo_readP6deviceP7uint8_tKi">
<span id="uart_fifo_read__deviceP.uint8_tP.iC"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga8ca70f5bfebb3ccc0ec45fa414014104"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_fifo_read</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint8_t *<em>rx_data</em>, <em class="property">const</em> int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read data from FIFO. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes read. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">rx_data</span></code>: Data container. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Container size.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218uart_irq_tx_enableP6device">
<span id="uart_irq_tx_enable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gad68f8cd03f1b26e67ffa5e93cef6da2d"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_tx_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable TX interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219uart_irq_tx_disableP6device">
<span id="uart_irq_tx_disable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga204af363c6d41b3e1a14f5222e4dcaf0"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_tx_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable TX interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217uart_irq_tx_readyP6device">
<span id="uart_irq_tx_ready__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga3fb63094db8cc9638f5e3dc316c27e34"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_irq_tx_ready</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check if Tx IRQ has been raised. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: If an IRQ is ready. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218uart_irq_rx_enableP6device">
<span id="uart_irq_rx_enable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga15c8bfa52040ebcec7c1ee7c143bd1e1"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_rx_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable RX interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219uart_irq_rx_disableP6device">
<span id="uart_irq_rx_disable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga773f3380c53f5f212fb4cf0d512bb00c"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_rx_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable RX interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217uart_irq_tx_emptyP6device">
<span id="uart_irq_tx_empty__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gae8dcd4b981b3759153c9252de890a6c6"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_irq_tx_empty</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check if nothing remains to be transmitted. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: If nothing remains to be transmitted. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217uart_irq_rx_readyP6device">
<span id="uart_irq_rx_ready__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gacb805d8366efabbd2fcbb382f35e233b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_irq_rx_ready</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check if Rx IRQ has been raised. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: If an IRQ is ready. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219uart_irq_err_enableP6device">
<span id="uart_irq_err_enable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga03a64446707f4944c4ba9b64a1c1e89c"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_err_enable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable error interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220uart_irq_err_disableP6device">
<span id="uart_irq_err_disable__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gad63d0205d63d6e6fd781b8f96a4c7464"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_err_disable</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable error interrupt in IER. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: If an IRQ is ready. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219uart_irq_is_pendingP6device">
<span id="uart_irq_is_pending__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gac37c0cd412f6f20ee462385ad881f267"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_irq_is_pending</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check if any IRQs is pending. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: If an IRQ is pending. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215uart_irq_updateP6device">
<span id="uart_irq_update__deviceP"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga3322392a94152704646c4d2556334e42"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_irq_update</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Update cached contents of IIR. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: Always. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221uart_irq_callback_setP6device19uart_irq_callback_t">
<span id="uart_irq_callback_set__deviceP.uart_irq_callback_t"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1ga27504192967191e3d8795acff0fde648"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">uart_irq_callback_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <a class="reference internal" href="#_CPPv219uart_irq_callback_t" title="uart_irq_callback_t">uart_irq_callback_t</a> <em>cb</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the IRQ callback function pointer. </p>
<p>This sets up the callback for IRQ. When an IRQ is triggered, the specified function will be called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">cb</span></code>: Pointer to the callback function.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212uart_drv_cmdP6device8uint32_t8uint32_t">
<span id="uart_drv_cmd__deviceP.uint32_t.uint32_t"></span><span class="target" id="Zephyrdc/db8/group__uart__interface_1gaeea775f79a4f0464aedb4d99baafb1a5"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">uart_drv_cmd</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, uint32_t <em>cmd</em>, uint32_t <em>p</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send extra command to driver. </p>
<p>Implementation and accepted commands are driver specific. Refer to the drivers for more information.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: UART device structure. </li>
<li><code class="docutils literal"><span class="pre">cmd</span></code>: Command to driver. </li>
<li><code class="docutils literal"><span class="pre">p</span></code>: Parameter to the command.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: If successful. </li>
<li><code class="docutils literal"><span class="pre">failed</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.UART_OPTION_AFCE">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga27d446bb2575207b5dbced3b61862ded"></span><code class="descname">UART_OPTION_AFCE</code></dt>
<dd><p>Options for <em>UART</em> initialization. </p>
</dd></dl>

<dl class="macro">
<dt id="c.LINE_CTRL_BAUD_RATE">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga1ddfc1debd63dc081dcefbff5683536f"></span><code class="descname">LINE_CTRL_BAUD_RATE</code></dt>
<dd><p>Common line controls for UART. </p>
</dd></dl>

<dl class="macro">
<dt id="c.LINE_CTRL_RTS">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga3156525e44b69afb6628dcb7ba3eaba0"></span><code class="descname">LINE_CTRL_RTS</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.LINE_CTRL_DTR">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1gae80405ceeeb42a9dd21a2e5e17125bf9"></span><code class="descname">LINE_CTRL_DTR</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.LINE_CTRL_DCD">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga5f048c983dc43f27356783de4c8d01c9"></span><code class="descname">LINE_CTRL_DCD</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.LINE_CTRL_DSR">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga11dc6587d2d6d83bf244ab9542bc8229"></span><code class="descname">LINE_CTRL_DSR</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.UART_ERROR_OVERRUN">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga7b0e17571b0d3f6380b7eed39bd41c56"></span><code class="descname">UART_ERROR_OVERRUN</code></dt>
<dd><p>Overrun error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.UART_ERROR_PARITY">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga2670f803413d1a03c2eb4250b8ba7be0"></span><code class="descname">UART_ERROR_PARITY</code></dt>
<dd><p>Parity error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.UART_ERROR_FRAMING">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga336c98ad1ad61f68b5b1b0bb1a1745cb"></span><code class="descname">UART_ERROR_FRAMING</code></dt>
<dd><p>Framing error. </p>
</dd></dl>

<dl class="macro">
<dt id="c.UART_ERROR_BREAK">
<span class="target" id="Zephyrdc/db8/group__uart__interface_1ga4204485582ed55f3e52f5d73aa3130b0"></span><code class="descname">UART_ERROR_BREAK</code></dt>
<dd><p>Break interrupt error: </p>
<p>A break interrupt was received. This happens when the serial input is held at a logic &#8216;0&#8217; state for longer than the sum of start time + data bits<ul class="simple">
<li>parity + stop bits. </li>
</ul>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv218uart_device_config">
<span id="uart_device_config"></span><span class="target" id="Zephyrd4/d6d/structuart__device__config"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">uart_device_config</code><br /></dt>
<dd><em>#include &lt;uart.h&gt;</em><p>UART device configuration. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">port</span></code>: Base port number </li>
<li><code class="docutils literal"><span class="pre">base</span></code>: Memory mapped base address </li>
<li><code class="docutils literal"><span class="pre">regs</span></code>: Register address </li>
<li><code class="docutils literal"><span class="pre">sys_clk_freq</span></code>: System clock frequency in Hz </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="Zephyrde/d2a/unionuart__device__config_8____unnamed____"></span><em class="property">union </em></dt>
<dd><div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt>
<span class="target" id="Zephyrde/d2a/unionuart__device__config_8____unnamed_____1a901555fb06e346cb065ceb9808dcfc25"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="Zephyrde/d2a/unionuart__device__config_8____unnamed_____1a593616de15330c0fb2d55e55410bf994"></span><code class="descname"></code></dt>
<dd></dd></dl>

<dl class="member">
<dt>
<span class="target" id="Zephyrde/d2a/unionuart__device__config_8____unnamed_____1a66373a9c960d5bb19f89068c5a2797b0"></span><code class="descname"></code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv215uart_driver_api">
<span id="uart_driver_api"></span><span class="target" id="Zephyrdd/de1/structuart__driver__api"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">uart_driver_api</code><br /></dt>
<dd><em>#include &lt;uart.h&gt;</em><p>Driver API structure. </p>
</dd></dl>

</div>
<div class="section" id="sensor-interface">
<h2><a class="toc-backref" href="#contents">Sensor Interface</a></h2>
<dl class="type">
<dt id="_CPPv2N16sensor_interface14sensor_channelE">
<span id="sensor_interface::sensor_channel"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gaaa1b502bc029b10d7b23b0a25ef4e934"></span><em class="property">enum </em><code class="descclassname">sensor_interface::</code><code class="descname">sensor_channel</code><br /></dt>
<dd><p>Sensor channels. </p>
<p><em>Values:</em></p>
<dl class="member">
<dt id="_CPPv2N16sensor_interface19SENSOR_CHAN_ACCEL_XE">
<span id="sensor_interface::SENSOR_CHAN_ACCEL_X"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934afa9238082f000350530ca77b2f513d4c"></span><code class="descname">SENSOR_CHAN_ACCEL_X</code><br /></dt>
<dd><p>Acceleration on the X axis, in m/s^2. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface19SENSOR_CHAN_ACCEL_YE">
<span id="sensor_interface::SENSOR_CHAN_ACCEL_Y"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a61c145468f01916c1a547fb38a1be9a8"></span><code class="descname">SENSOR_CHAN_ACCEL_Y</code><br /></dt>
<dd><p>Acceleration on the Y axis, in m/s^2. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface19SENSOR_CHAN_ACCEL_ZE">
<span id="sensor_interface::SENSOR_CHAN_ACCEL_Z"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a78e06bb48cfe06e42829816ad4cb5a0f"></span><code class="descname">SENSOR_CHAN_ACCEL_Z</code><br /></dt>
<dd><p>Acceleration on the Z axis, in m/s^2. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface21SENSOR_CHAN_ACCEL_ANYE">
<span id="sensor_interface::SENSOR_CHAN_ACCEL_ANY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934aa07361cd2a1831d229b8654ce1ff1014"></span><code class="descname">SENSOR_CHAN_ACCEL_ANY</code><br /></dt>
<dd><p>Acceleration on any axis. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_GYRO_XE">
<span id="sensor_interface::SENSOR_CHAN_GYRO_X"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934ac5709b77f0eb69972ccc055f927e5015"></span><code class="descname">SENSOR_CHAN_GYRO_X</code><br /></dt>
<dd><p>Angular velocity around the X axis, in radians/s. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_GYRO_YE">
<span id="sensor_interface::SENSOR_CHAN_GYRO_Y"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a4a9533172105fd2e55d96e0122a48847"></span><code class="descname">SENSOR_CHAN_GYRO_Y</code><br /></dt>
<dd><p>Angular velocity around the Y axis, in radians/s. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_GYRO_ZE">
<span id="sensor_interface::SENSOR_CHAN_GYRO_Z"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a9b6b9d13cd8d82449823d65779a87a39"></span><code class="descname">SENSOR_CHAN_GYRO_Z</code><br /></dt>
<dd><p>Angular velocity around the Z axis, in radians/s. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_CHAN_GYRO_ANYE">
<span id="sensor_interface::SENSOR_CHAN_GYRO_ANY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a2cef52cbad660bdcabdf6293c2744bb5"></span><code class="descname">SENSOR_CHAN_GYRO_ANY</code><br /></dt>
<dd><p>Angular velocity on any axis. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_MAGN_XE">
<span id="sensor_interface::SENSOR_CHAN_MAGN_X"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a171f37ba152d34f75ff745cb848b3240"></span><code class="descname">SENSOR_CHAN_MAGN_X</code><br /></dt>
<dd><p>Magnetic field on the X axis, in Gauss. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_MAGN_YE">
<span id="sensor_interface::SENSOR_CHAN_MAGN_Y"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a2b4f1764f47428c528447347d7730942"></span><code class="descname">SENSOR_CHAN_MAGN_Y</code><br /></dt>
<dd><p>Magnetic field on the Y axis, in Gauss. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_CHAN_MAGN_ZE">
<span id="sensor_interface::SENSOR_CHAN_MAGN_Z"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a2a2115051ded019a57ece5a00f86ea61"></span><code class="descname">SENSOR_CHAN_MAGN_Z</code><br /></dt>
<dd><p>Magnetic field on the Z axis, in Gauss. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_CHAN_MAGN_ANYE">
<span id="sensor_interface::SENSOR_CHAN_MAGN_ANY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934ad222b487e075b6c63fb4dcfdc6d2634b"></span><code class="descname">SENSOR_CHAN_MAGN_ANY</code><br /></dt>
<dd><p>Magnetic field on any axis. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface16SENSOR_CHAN_TEMPE">
<span id="sensor_interface::SENSOR_CHAN_TEMP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a22ed4778240da23841e030a633eb31b6"></span><code class="descname">SENSOR_CHAN_TEMP</code><br /></dt>
<dd><p>Temperature in degrees Celsius. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface17SENSOR_CHAN_PRESSE">
<span id="sensor_interface::SENSOR_CHAN_PRESS"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a14cd68844542e23d1b641a2bc54132a9"></span><code class="descname">SENSOR_CHAN_PRESS</code><br /></dt>
<dd><p>Pressure in kilopascal. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface16SENSOR_CHAN_PROXE">
<span id="sensor_interface::SENSOR_CHAN_PROX"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934abaec2c1347ef0035221dd4d9c34a4774"></span><code class="descname">SENSOR_CHAN_PROX</code><br /></dt>
<dd><p>Proximity. Adimensional. A value of 1 indicates that an object is close. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_CHAN_HUMIDITYE">
<span id="sensor_interface::SENSOR_CHAN_HUMIDITY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934ad08ddb6c9cd71c853a121f426fcea042"></span><code class="descname">SENSOR_CHAN_HUMIDITY</code><br /></dt>
<dd><p>Humidity, in milli percent. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface17SENSOR_CHAN_LIGHTE">
<span id="sensor_interface::SENSOR_CHAN_LIGHT"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934a6e91196c11d080c3f5df55fda190e19d"></span><code class="descname">SENSOR_CHAN_LIGHT</code><br /></dt>
<dd><p>Illuminance in visible spectrum, in lux. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface14SENSOR_CHAN_IRE">
<span id="sensor_interface::SENSOR_CHAN_IR"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934ad725fe5778f000a17f93f83dab31132c"></span><code class="descname">SENSOR_CHAN_IR</code><br /></dt>
<dd><p>Illuminance in infra-red spectrum, in lux. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_CHAN_ALTITUDEE">
<span id="sensor_interface::SENSOR_CHAN_ALTITUDE"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934af5ba63bfef1c64c8a96ae7fba4f35512"></span><code class="descname">SENSOR_CHAN_ALTITUDE</code><br /></dt>
<dd><p>Altitude, in meters </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface15SENSOR_CHAN_ALLE">
<span id="sensor_interface::SENSOR_CHAN_ALL"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_gaaa1b502bc029b10d7b23b0a25ef4e934_1ggaaa1b502bc029b10d7b23b0a25ef4e934ab275027eb550b2b075c44917634eca2c"></span><code class="descname">SENSOR_CHAN_ALL</code><br /></dt>
<dd><p>All channels. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv2N16sensor_interface19sensor_trigger_typeE">
<span id="sensor_interface::sensor_trigger_type"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga08215279400e8c9eb05ce4e4f0898ffd"></span><em class="property">enum </em><code class="descclassname">sensor_interface::</code><code class="descname">sensor_trigger_type</code><br /></dt>
<dd><p>Sensor trigger types. </p>
<p><em>Values:</em></p>
<dl class="member">
<dt id="_CPPv2N16sensor_interface17SENSOR_TRIG_TIMERE">
<span id="sensor_interface::SENSOR_TRIG_TIMER"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffdabf92b196394726ec90f1d61586a7f023"></span><code class="descname">SENSOR_TRIG_TIMER</code><br /></dt>
<dd><p>Timer-based trigger, useful when the sensor does not have an interrupt line. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface22SENSOR_TRIG_DATA_READYE">
<span id="sensor_interface::SENSOR_TRIG_DATA_READY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffdaf7c161e309c267a7dd6daf2ad176f44f"></span><code class="descname">SENSOR_TRIG_DATA_READY</code><br /></dt>
<dd><p>Trigger fires whenever new data is ready. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface17SENSOR_TRIG_DELTAE">
<span id="sensor_interface::SENSOR_TRIG_DELTA"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffda3bb90a3334bcf613c9efbdf2ed05f855"></span><code class="descname">SENSOR_TRIG_DELTA</code><br /></dt>
<dd><p>Trigger fires when the selected channel varies significantly. This includes any-motion detection when the channel is acceleration or gyro. If detection is based on slope between successive channel readings, the slope threshold is configured via the <a class="reference internal" href="#Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940bac4538665a244cb7f18fc053c40134302"><span class="std std-ref">SENSOR_ATTR_SLOPE_TH</span></a> and <a class="reference internal" href="#Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940baf510b32b2e2395bbcf1c8fd7159ed2a1"><span class="std std-ref">SENSOR_ATTR_SLOPE_DUR</span></a> attributes. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_TRIG_NEAR_FARE">
<span id="sensor_interface::SENSOR_TRIG_NEAR_FAR"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffda448226d83b28c2862c353a8cda7be0d5"></span><code class="descname">SENSOR_TRIG_NEAR_FAR</code><br /></dt>
<dd><p>Trigger fires when a near/far event is detected. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface21SENSOR_TRIG_THRESHOLDE">
<span id="sensor_interface::SENSOR_TRIG_THRESHOLD"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffda8f875f881b6540eebc28e3d6a7d46606"></span><code class="descname">SENSOR_TRIG_THRESHOLD</code><br /></dt>
<dd><p>Trigger fires when channel reading transitions configured thresholds. The thresholds are configured via the <a class="reference internal" href="#Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940baee644485ab5f64e7c5273bbe562deaaa"><span class="std std-ref">SENSOR_ATTR_LOWER_THRESH</span></a> and <a class="reference internal" href="#Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940ba5af51bd0640a87a94476eee112a4460b"><span class="std std-ref">SENSOR_ATTR_UPPER_THRESH</span></a> attributes. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface15SENSOR_TRIG_TAPE">
<span id="sensor_interface::SENSOR_TRIG_TAP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffdae49a25e6400f0753f6bac8a7d136200d"></span><code class="descname">SENSOR_TRIG_TAP</code><br /></dt>
<dd><p>Trigger fires when a single tap is detected. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface22SENSOR_TRIG_DOUBLE_TAPE">
<span id="sensor_interface::SENSOR_TRIG_DOUBLE_TAP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga08215279400e8c9eb05ce4e4f0898ffd_1gga08215279400e8c9eb05ce4e4f0898ffdab95e52584a6bc3343181f495cd4cb2ef"></span><code class="descname">SENSOR_TRIG_DOUBLE_TAP</code><br /></dt>
<dd><p>Trigger fires when a double tap is detected. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv2N16sensor_interface16sensor_attributeE">
<span id="sensor_interface::sensor_attribute"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga0dcb6842bc969492bd1c9eb49708940b"></span><em class="property">enum </em><code class="descclassname">sensor_interface::</code><code class="descname">sensor_attribute</code><br /></dt>
<dd><p>Sensor attribute types. </p>
<p><em>Values:</em></p>
<dl class="member">
<dt id="_CPPv2N16sensor_interface30SENSOR_ATTR_SAMPLING_FREQUENCYE">
<span id="sensor_interface::SENSOR_ATTR_SAMPLING_FREQUENCY"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940bacb07e3508ea5503dbcdceee3f17d2291"></span><code class="descname">SENSOR_ATTR_SAMPLING_FREQUENCY</code><br /></dt>
<dd><p>Sensor sampling frequency, i.e. how many times a second the sensor takes a measurement. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface24SENSOR_ATTR_LOWER_THRESHE">
<span id="sensor_interface::SENSOR_ATTR_LOWER_THRESH"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940baee644485ab5f64e7c5273bbe562deaaa"></span><code class="descname">SENSOR_ATTR_LOWER_THRESH</code><br /></dt>
<dd><p>Lower threshold for trigger. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface24SENSOR_ATTR_UPPER_THRESHE">
<span id="sensor_interface::SENSOR_ATTR_UPPER_THRESH"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940ba5af51bd0640a87a94476eee112a4460b"></span><code class="descname">SENSOR_ATTR_UPPER_THRESH</code><br /></dt>
<dd><p>Upper threshold for trigger. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface20SENSOR_ATTR_SLOPE_THE">
<span id="sensor_interface::SENSOR_ATTR_SLOPE_TH"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940bac4538665a244cb7f18fc053c40134302"></span><code class="descname">SENSOR_ATTR_SLOPE_TH</code><br /></dt>
<dd><p>Threshold for any-motion (slope) trigger. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface21SENSOR_ATTR_SLOPE_DURE">
<span id="sensor_interface::SENSOR_ATTR_SLOPE_DUR"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940baf510b32b2e2395bbcf1c8fd7159ed2a1"></span><code class="descname">SENSOR_ATTR_SLOPE_DUR</code><br /></dt>
<dd><p>Duration for which the slope values needs to be outside the threshold for the trigger to fire. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface24SENSOR_ATTR_OVERSAMPLINGE">
<span id="sensor_interface::SENSOR_ATTR_OVERSAMPLING"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940ba3d32987f75284d80d3f64bf44f5c6ccd"></span><code class="descname">SENSOR_ATTR_OVERSAMPLING</code><br /></dt>
<dd><p>Oversampling factor </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface22SENSOR_ATTR_FULL_SCALEE">
<span id="sensor_interface::SENSOR_ATTR_FULL_SCALE"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940bad30df3100fb6b285a6a786fdc77234d3"></span><code class="descname">SENSOR_ATTR_FULL_SCALE</code><br /></dt>
<dd><p>Sensor range, in SI units. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface18SENSOR_ATTR_OFFSETE">
<span id="sensor_interface::SENSOR_ATTR_OFFSET"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940ba332935dcb6f7e228cb9c595a545079fd"></span><code class="descname">SENSOR_ATTR_OFFSET</code><br /></dt>
<dd><p>The sensor value returned will be altered by the amount indicated by offset: final_value = <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> + offset. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv2N16sensor_interface24SENSOR_ATTR_CALIB_TARGETE">
<span id="sensor_interface::SENSOR_ATTR_CALIB_TARGET"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_ga0dcb6842bc969492bd1c9eb49708940b_1gga0dcb6842bc969492bd1c9eb49708940ba3043381b539610a8b424f12d76474bdf"></span><code class="descname">SENSOR_ATTR_CALIB_TARGET</code><br /></dt>
<dd><p>Calibration target. This will be used by the internal chip&#8217;s algorithms to calibrate itself on a certain axis, or all of them. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv224sensor_trigger_handler_t">
<span id="sensor_trigger_handler_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga6af2b3cb258e8013ca9134190723b953"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">sensor_trigger_handler_t</code><br /></dt>
<dd><p>Callback API upon firing of a trigger. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code>: Pointer to the sensor device </li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sensor_trigger</span> <span class="pre">*trigger</span></code>: The trigger </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv217sensor_attr_set_t">
<span id="sensor_attr_set_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gaf231f6b17648e70d96de9c10ac6d4a14"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">sensor_attr_set_t</code><br /></dt>
<dd><p>Callback API upon setting a sensor&#8217;s attributes. </p>
<p>See sensor_attr_set() for argument description </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv220sensor_trigger_set_t">
<span id="sensor_trigger_set_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga151ffdd09206f35c703930106fd96163"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">sensor_trigger_set_t</code><br /></dt>
<dd><p>Callback API for setting a sensor&#8217;s trigger and handler. </p>
<p>See sensor_trigger_set() for argument description </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv221sensor_sample_fetch_t">
<span id="sensor_sample_fetch_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gad733a8356d6555bb3e6a811fa1b75fcb"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">sensor_sample_fetch_t</code><br /></dt>
<dd><p>Callback API for fetching data from a sensor. </p>
<p>See sensor_sample_fetch() for argument descriptor </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv220sensor_channel_get_t">
<span id="sensor_channel_get_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga730a1c7933bfb12e8a9d16015191bbaf"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">sensor_channel_get_t</code><br /></dt>
<dd><p>Callback API for getting a reading from a sensor. </p>
<p>See sensor_channel_get() for argument descriptor </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215sensor_attr_setP6device14sensor_channel16sensor_attributePK12sensor_value">
<span id="sensor_attr_set__deviceP.sensor_channel.sensor_attribute.sensor_valueCP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gafb70d07cdfd5aa85e9d853c7ed15bd03"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sensor_attr_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">enum</em> <a class="reference internal" href="../subsystems/sensor.html#_CPPv214sensor_channel" title="sensor_channel">sensor_channel</a> <em>chan</em>, <em class="property">enum</em> sensor_attribute <em>attr</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set an attribute for a sensor. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code if failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the sensor device </li>
<li><code class="docutils literal"><span class="pre">chan</span></code>: The channel the attribute belongs to, if any. Some attributes may only be set for all channels of a device, depending on device capabilities. </li>
<li><code class="docutils literal"><span class="pre">attr</span></code>: The attribute to set </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: The value to set the attribute to</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218sensor_trigger_setP6deviceP14sensor_trigger24sensor_trigger_handler_t">
<span id="sensor_trigger_set__deviceP.sensor_triggerP.sensor_trigger_handler_t"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga7fea95004cf12755db2cdc402147dfdd"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sensor_trigger_set</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv214sensor_trigger" title="sensor_trigger">sensor_trigger</a> *<em>trig</em>, <a class="reference internal" href="#_CPPv224sensor_trigger_handler_t" title="sensor_trigger_handler_t">sensor_trigger_handler_t</a> <em>handler</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Activate a sensor&#8217;s trigger and set the trigger handler. </p>
<p>The handler will be called from a fiber, so I2C or SPI operations are safe. However, the fiber&#8217;s stack is limited and defined by the driver. It is currently up to the caller to ensure that the handler does not overflow the stack.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code if failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the sensor device </li>
<li><code class="docutils literal"><span class="pre">trig</span></code>: The trigger to activate </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: The function that should be called when the trigger fires</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219sensor_sample_fetchP6device">
<span id="sensor_sample_fetch__deviceP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gab799376805eab1b6a9c7c22035c59c0b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sensor_sample_fetch</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Fetch a sample from the sensor and store it in an internal driver buffer. </p>
<p>Read all of a sensor&#8217;s active channels and, if necessary, perform any additional operations necessary to make the values useful. The user may then get individual channel values by calling sensor_channel_get.</p>
<p>Since the function communicates with the sensor device, it is unsafe to call it in an ISR if the device is connected via I2C or SPI.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code if failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the sensor device</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224sensor_sample_fetch_chanP6device14sensor_channel">
<span id="sensor_sample_fetch_chan__deviceP.sensor_channel"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gae7ab9727ac52288fa6c097915e44154b"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sensor_sample_fetch_chan</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">enum</em> <a class="reference internal" href="../subsystems/sensor.html#_CPPv214sensor_channel" title="sensor_channel">sensor_channel</a> <em>type</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Fetch a sample from the sensor and store it in an internal driver buffer. </p>
<p>Read and compute compensation for one type of sensor data (magnetometer, accelerometer, etc). The user may then get individual channel values by calling sensor_channel_get.</p>
<p>This is mostly implemented by multi function devices enabling reading at different sampling rates.</p>
<p>Since the function communicates with the sensor device, it is unsafe to call it in an ISR if the device is connected via I2C or SPI.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code if failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the sensor device </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: The channel that needs updated</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218sensor_channel_getP6device14sensor_channelP12sensor_value">
<span id="sensor_channel_get__deviceP.sensor_channel.sensor_valueP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga7003d9f98e644eab7375080c1bea133c"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sensor_channel_get</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="device.html#_CPPv26device" title="device">device</a> *<em>dev</em>, <em class="property">enum</em> <a class="reference internal" href="../subsystems/sensor.html#_CPPv214sensor_channel" title="sensor_channel">sensor_channel</a> <em>chan</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get a reading from a sensor device. </p>
<p>Return a useful value for a particular channel, from the driver&#8217;s internal data. Before calling this function, a sample must be obtained by calling sensor_sample_fetch or sensor_sample_fetch_chan. It is guaranteed that two subsequent calls of this function for the same channels will yield the same value, if sensor_sample_fetch or sensor_sample_fetch_chan has not been called in the meantime.</p>
<p>For vectorial data samples you can request all axes in just one call by passing the specific channel with _ANY suffix. The sample will be returned at val[0], val[1] and val[2] (X, Y and Z in that order).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if successful, negative errno code if failure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">dev</span></code>: Pointer to the sensor device </li>
<li><code class="docutils literal"><span class="pre">chan</span></code>: The channel to read </li>
<li><code class="docutils literal"><span class="pre">val</span></code>: Where to store the value</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215sensor_ms2_to_gPK12sensor_value">
<span id="sensor_ms2_to_g__sensor_valueCP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1gab797f2f578b1c9cc44f54ab5d503bbf8"></span><em class="property">static</em> int32_t <code class="descclassname"></code><code class="descname">sensor_ms2_to_g</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>ms2</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper function to convert acceleration from m/s^2 to Gs. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The converted value, in Gs. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ms2</span></code>: A pointer to a <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> struct holding the acceleration, in m/s^2.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215sensor_g_to_ms27int32_tP12sensor_value">
<span id="sensor_g_to_ms2__int32_t.sensor_valueP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga6ab9ce9c6ee2e52d197e5cb4ccd88979"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sensor_g_to_ms2</code><span class="sig-paren">(</span>int32_t <em>g</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>ms2</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper function to convert acceleration from Gs to m/s^2. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">g</span></code>: The G value to be converted. </li>
<li><code class="docutils literal"><span class="pre">ms2</span></code>: A pointer to a <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> struct, where the result is stored. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221sensor_rad_to_degreesPK12sensor_value">
<span id="sensor_rad_to_degrees__sensor_valueCP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga040a907c8934baab66d27b8dfb1ea220"></span><em class="property">static</em> int32_t <code class="descclassname"></code><code class="descname">sensor_rad_to_degrees</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>rad</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper function for converting radians to degrees. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The converted value, in degrees. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">rad</span></code>: A pointer to a <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> struct, holding the value in radians.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221sensor_degrees_to_rad7int32_tP12sensor_value">
<span id="sensor_degrees_to_rad__int32_t.sensor_valueP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga39d4b84f5d792e27b2d6d5eb6a2ccb0d"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sensor_degrees_to_rad</code><span class="sig-paren">(</span>int32_t <em>d</em>, <em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>rad</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper function for converting degrees to radians. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">d</span></code>: The value (in degrees) to be converted. </li>
<li><code class="docutils literal"><span class="pre">rad</span></code>: A pointer to a <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> struct, where the result is stored. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222sensor_value_to_doubleP12sensor_value">
<span id="sensor_value_to_double__sensor_valueP"></span><span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga975fbbca4f0cb6d11183bc60e080d4ab"></span><em class="property">static</em> double <code class="descclassname"></code><code class="descname">sensor_value_to_double</code><span class="sig-paren">(</span><em class="property">struct</em> <a class="reference internal" href="#_CPPv212sensor_value" title="sensor_value">sensor_value</a> *<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Helper function for converting struct <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> to double. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The converted value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">val</span></code>: A pointer to a <a class="reference internal" href="../subsystems/sensor.html#Zephyrdc/da4/structsensor__value"><span class="std std-ref">sensor_value</span></a> struct. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SENSOR_G">
<span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga0066e049c4f084305ca2b978e5c7454d"></span><code class="descname">SENSOR_G</code></dt>
<dd><p>The value of gravitational constant in micro m/s^2. </p>
</dd></dl>

<dl class="macro">
<dt id="c.SENSOR_PI">
<span class="target" id="Zephyrd1/d98/group__sensor__interface_1ga6ebdc2f6942334de3cc248a53db7df33"></span><code class="descname">SENSOR_PI</code></dt>
<dd><p>The value of constant PI in micros. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv212sensor_value">
<span id="sensor_value"></span><span class="target" id="Zephyrdc/da4/structsensor__value"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">sensor_value</code><br /></dt>
<dd><em>#include &lt;sensor.h&gt;</em><p>Representation of a sensor readout value. </p>
<p>The value is represented as having an integer and a fractional part, and can be obtained using the formula val1 + val2 * 10^(-6). </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv214sensor_trigger">
<span id="sensor_trigger"></span><span class="target" id="Zephyrd3/df2/structsensor__trigger"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">sensor_trigger</code><br /></dt>
<dd><em>#include &lt;sensor.h&gt;</em><p>Sensor trigger spec. </p>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="power_management_api.html" class="btn btn-neutral float-right" title="Power Management APIs" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="device.html" class="btn btn-neutral" title="Device Driver Interface" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Intel Corporation, Wind River Systems, Inc.
      Last updated on Jan 26, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.6.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>