

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel APIs &mdash; Zephyr Project Documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Zephyr Project Documentation" href="../index.html"/>
        <link rel="up" title="API Documentation" href="api.html"/>
        <link rel="next" title="Device Driver Interface" href="device.html"/>
        <link rel="prev" title="API Documentation" href="api.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Zephyr Project
          

          
          </a>

          
            
            
              <div class="version">
                1.6.99
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introducing_zephyr.html">Introducing Zephyr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boards/boards.html">Supported Boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel/kernel.html">Zephyr Kernel Primer (version 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../application/application.html">Application Development Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../porting/porting.html">Porting Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/drivers.html">Device Drivers and Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../subsystems/subsystems.html">Subsystems</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#threads">Threads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workqueues">Workqueues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clocks">Clocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timers">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-slabs">Memory Slabs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-pools">Memory Pools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heap-memory-pool">Heap Memory Pool</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semaphores">Semaphores</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mutexes">Mutexes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alerts">Alerts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fifos">Fifos</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lifos">Lifos</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stacks">Stacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-queues">Message Queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mailboxes">Mailboxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipes">Pipes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interrupt-service-routines-isrs">Interrupt Service Routines (ISRs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-services">Atomic Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floating-point-services">Floating Point Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ring-buffers">Ring Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-apis">Legacy APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="device.html">Device Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="bluetooth.html">Bluetooth API</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_interfaces.html">Input / Output Driver APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_management_api.html">Power Management APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="file_system.html">File System APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../samples/samples.html">Samples and Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/kconfig/index.html">Configuration Options Reference Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/code.html">Contributing Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSING.html">Licensing of Zephyr Project components</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Zephyr Project</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="api.html">API Documentation</a> &raquo;</li>
      
    <li>Kernel APIs</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/kernel_api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-apis">
<span id="id1"></span><h1>Kernel APIs</h1>
<p>This section contains APIs for the kernel&#8217;s core services,
as described in the <a class="reference internal" href="../kernel/kernel.html#kernel"><span class="std std-ref">Zephyr Kernel Primer (version 2)</span></a>.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Unless otherwise noted these APIs can be used by threads, but not by ISRs.</p>
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#threads" id="id2">Threads</a></li>
<li><a class="reference internal" href="#workqueues" id="id3">Workqueues</a></li>
<li><a class="reference internal" href="#clocks" id="id4">Clocks</a></li>
<li><a class="reference internal" href="#timers" id="id5">Timers</a></li>
<li><a class="reference internal" href="#memory-slabs" id="id6">Memory Slabs</a></li>
<li><a class="reference internal" href="#memory-pools" id="id7">Memory Pools</a></li>
<li><a class="reference internal" href="#heap-memory-pool" id="id8">Heap Memory Pool</a></li>
<li><a class="reference internal" href="#semaphores" id="id9">Semaphores</a></li>
<li><a class="reference internal" href="#mutexes" id="id10">Mutexes</a></li>
<li><a class="reference internal" href="#alerts" id="id11">Alerts</a></li>
<li><a class="reference internal" href="#fifos" id="id12">Fifos</a></li>
<li><a class="reference internal" href="#lifos" id="id13">Lifos</a></li>
<li><a class="reference internal" href="#stacks" id="id14">Stacks</a></li>
<li><a class="reference internal" href="#message-queues" id="id15">Message Queues</a></li>
<li><a class="reference internal" href="#mailboxes" id="id16">Mailboxes</a></li>
<li><a class="reference internal" href="#pipes" id="id17">Pipes</a></li>
<li><a class="reference internal" href="#interrupt-service-routines-isrs" id="id18">Interrupt Service Routines (ISRs)</a></li>
<li><a class="reference internal" href="#atomic-services" id="id19">Atomic Services</a></li>
<li><a class="reference internal" href="#floating-point-services" id="id20">Floating Point Services</a></li>
<li><a class="reference internal" href="#ring-buffers" id="id21">Ring Buffers</a></li>
<li><a class="reference internal" href="#legacy-apis" id="id22">Legacy APIs</a></li>
</ul>
</div>
<div class="section" id="threads">
<h2><a class="toc-backref" href="#contents">Threads</a></h2>
<p>A thread is an independently scheduled series of instructions that implements
a portion of an application&#8217;s processing. Threads are used to perform processing
that is too lengthy or too complex to be performed by an ISR.
(See <a class="reference internal" href="../kernel/threads/threads.html#threads-v2"><span class="std std-ref">Threads</span></a>.)</p>
<dl class="type">
<dt id="_CPPv216k_thread_entry_t">
<span id="k_thread_entry_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1gaf1bd193a26c6e6a8658140185cae42e1"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">k_thread_entry_t</code><br /></dt>
<dd><p>Thread entry point function type. </p>
<p>A thread&#8217;s entry point function is invoked when the thread starts executing. Up to 3 argument values can be passed to the function.</p>
<p>The thread terminates execution permanently if the entry point function returns. The thread is responsible for releasing any shared resources it may own (such as mutexes and dynamically allocated memory), prior to returning.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">p1</span></code>: First argument. </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: Second argument. </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: Third argument.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_thread_spawnPc6size_t16k_thread_entry_tPvPvPvi8uint32_t7int32_t">
<span id="k_thread_spawn__cP.s.k_thread_entry_t.voidP.voidP.voidP.i.uint32_t.int32_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga6d8ec29527b1b70ade42574d4808bbfd"></span>k_tid_t <code class="descclassname"></code><code class="descname">k_thread_spawn</code><span class="sig-paren">(</span>char *<em>stack</em>, size_t <em>stack_size</em>, <a class="reference internal" href="#_CPPv216k_thread_entry_t" title="k_thread_entry_t">k_thread_entry_t</a> <em>entry</em>, void *<em>p1</em>, void *<em>p2</em>, void *<em>p3</em>, int <em>prio</em>, uint32_t <em>options</em>, int32_t <em>delay</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Spawn a thread. </p>
<p>This routine initializes a thread, then schedules it for execution.</p>
<p>The new thread may be scheduled for immediate execution or a delayed start. If the newly spawned thread does not have a delayed start the kernel scheduler may preempt the current thread to allow the new thread to execute.</p>
<p>Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using &#8220;|&#8221; (the logical OR operator).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ID of new thread. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to the stack space. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Thread entry function. </li>
<li><code class="docutils literal"><span class="pre">p1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: 3rd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Thread priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Thread options. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Scheduling delay (in milliseconds), or K_NO_WAIT (for no delay).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv27k_sleep7int32_t">
<span id="k_sleep__int32_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1gaab7dcea855d4dec363ad8647a652645b"></span>void <code class="descclassname"></code><code class="descname">k_sleep</code><span class="sig-paren">(</span>int32_t <em>duration</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Put the current thread to sleep. </p>
<p>This routine puts the current thread to sleep for <em>duration</em> milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">duration</span></code>: Number of milliseconds to sleep.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_busy_wait8uint32_t">
<span id="k_busy_wait__uint32_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga550b642e071480323e589866abb99c22"></span>void <code class="descclassname"></code><code class="descname">k_busy_wait</code><span class="sig-paren">(</span>uint32_t <em>usec_to_wait</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Cause the current thread to busy wait. </p>
<p>This routine causes the current thread to execute a &#8220;do nothing&#8221; loop for <em>usec_to_wait</em> microseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv27k_yieldv">
<span id="k_yield__void"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga08a3484c33444ecedc2d71d78495a295"></span>void <code class="descclassname"></code><code class="descname">k_yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Yield the current thread. </p>
<p>This routine causes the current thread to yield execution to another thread of the same or higher priority. If there are no other ready threads of the same or higher priority, the routine returns immediately.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv28k_wakeup7k_tid_t">
<span id="k_wakeup__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga9275a019c8ff3c7fe49a81f8c078157e"></span>void <code class="descclassname"></code><code class="descname">k_wakeup</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Wake up a sleeping thread. </p>
<p>This routine prematurely wakes up <em>thread</em> from sleeping.</p>
<p>If <em>thread</em> is not currently sleeping, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to wake.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_current_getv">
<span id="k_current_get__void"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga3127f70fe54deec9bd5256ca5c360ecc"></span>k_tid_t <code class="descclassname"></code><code class="descname">k_current_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Get thread ID of the current thread. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ID of current thread. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_thread_cancel7k_tid_t">
<span id="k_thread_cancel__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga7259319d3a8a86a491a0a8f1d1a671e4"></span>int <code class="descclassname"></code><code class="descname">k_thread_cancel</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Cancel thread performing a delayed start. </p>
<p>This routine prevents <em>thread</em> from executing if it has not yet started execution. The thread must be re-spawned before it will execute.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to cancel.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Thread spawning cancelled. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Thread has already started executing. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_thread_abort7k_tid_t">
<span id="k_thread_abort__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga1f44bb0307bea7a97227764ecd7bf963"></span>void <code class="descclassname"></code><code class="descname">k_thread_abort</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Abort a thread. </p>
<p>This routine permanently stops execution of <em>thread</em>. The thread is taken off all kernel queues it is part of (i.e. the ready queue, the timeout queue, or a kernel object wait queue). However, any kernel resources the thread might currently own (such as mutexes or memory blocks) are not released. It is the responsibility of the caller of this routine to ensure all necessary cleanup is performed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to abort.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_thread_priority_get7k_tid_t">
<span id="k_thread_priority_get__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga3a46ed8ad2c3b12416fafe11325f82b3"></span>int <code class="descclassname"></code><code class="descname">k_thread_priority_get</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get a thread&#8217;s priority. </p>
<p>This routine gets the priority of <em>thread</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Priority of <em>thread</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread whose priority is needed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_thread_priority_set7k_tid_ti">
<span id="k_thread_priority_set__k_tid_t.i"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga24e50a60c524d1eb22fe21cdf269b6a6"></span>void <code class="descclassname"></code><code class="descname">k_thread_priority_set</code><span class="sig-paren">(</span>k_tid_t <em>thread</em>, int <em>prio</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set a thread&#8217;s priority. </p>
<p>This routine immediately changes the priority of <em>thread</em>.</p>
<p>Rescheduling can occur immediately depending on the priority <em>thread</em> is set to:</p>
<p><ul class="simple">
<li>If its priority is raised above the priority of the caller of this function, and the caller is preemptible, <em>thread</em> will be scheduled in.</li>
<li>If the caller operates on itself, it lowers its priority below that of other threads in the system, and the caller is preemptible, the thread of highest priority will be scheduled in.</li>
</ul>
</p>
<p>Priority can be assigned in the range of -CONFIG_NUM_COOP_PRIORITIES to CONFIG_NUM_PREEMPT_PRIORITIES-1, where -CONFIG_NUM_COOP_PRIORITIES is the highest priority.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Changing the priority of a thread currently involved in mutex priority inheritance may result in undefined behavior.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread whose priority is to be set. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: New priority.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_thread_suspend7k_tid_t">
<span id="k_thread_suspend__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga66cf8682fb65870eceb5e57d667a8d4e"></span>void <code class="descclassname"></code><code class="descname">k_thread_suspend</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Suspend a thread. </p>
<p>This routine prevents the kernel scheduler from making <em>thread</em> the current thread. All other internal operations on <em>thread</em> are still performed; for example, any timeout it is waiting on keeps ticking, kernel objects it is waiting on are still handed to it, etc.</p>
<p>If <em>thread</em> is already suspended, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to suspend.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_thread_resume7k_tid_t">
<span id="k_thread_resume__k_tid_t"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga117b26f8569ec3045ead1fad1851663d"></span>void <code class="descclassname"></code><code class="descname">k_thread_resume</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Resume a suspended thread. </p>
<p>This routine allows the kernel scheduler to make <em>thread</em> the current thread, when it is next eligible for that role.</p>
<p>If <em>thread</em> is not currently suspended, the routine has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread to resume.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222k_sched_time_slice_set7int32_ti">
<span id="k_sched_time_slice_set__int32_t.i"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga877c1bfeffbf8f097d1656f9e10a66e8"></span>void <code class="descclassname"></code><code class="descname">k_sched_time_slice_set</code><span class="sig-paren">(</span>int32_t <em>slice</em>, int <em>prio</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set time-slicing period and scope. </p>
<p>This routine specifies how the scheduler will perform time slicing of preemptible threads.</p>
<p>To enable time slicing, <em>slice</em> must be non-zero. The scheduler ensures that no thread runs for more than the specified time limit before other threads of that priority are given a chance to execute. Any thread whose priority is higher than <em>prio</em> is exempted, and may execute as long as desired without being pre-empted due to time slicing.</p>
<p>Time slicing only limits the maximum amount of time a thread may continuously execute. Once the scheduler selects a thread for execution, there is no minimum guaranteed time the thread will execute before threads of greater or equal priority are scheduled.</p>
<p>When the current thread is the only one of that priority eligible for execution, this routine has no effect; the thread is immediately rescheduled after the slice period expires.</p>
<p>To disable timeslicing, set both <em>slice</em> and <em>prio</em> to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slice</span></code>: Maximum time slice length (in milliseconds). </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Highest thread priority level eligible for time slicing.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_sched_lockv">
<span id="k_sched_lock__void"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga4f0c5d0b9f279b12a4ad97db0c116a5f"></span>void <code class="descclassname"></code><code class="descname">k_sched_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Lock the scheduler. </p>
<p>This routine prevents the current thread from being preempted by another thread by instructing the scheduler to treat it as a cooperative thread. If the thread subsequently performs an operation that makes it unready, it will be context switched out in the normal manner. When the thread again becomes the current thread, its non-preemptible status is maintained.</p>
<p>This routine can be called recursively.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>k_sched_lock() and k_sched_unlock() should normally be used when the operation being performed can be safely interrupted by ISRs. However, if the amount of processing involved is very small, better performance may be obtained by using irq_lock() and irq_unlock().</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_sched_unlockv">
<span id="k_sched_unlock__void"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga7b26f64523cc4c36522cc828ccf85580"></span>void <code class="descclassname"></code><code class="descname">k_sched_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Unlock the scheduler. </p>
<p>This routine reverses the effect of a previous call to k_sched_lock(). A thread must call the routine once for each time it called k_sched_lock() before the thread becomes preemptible.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224k_thread_custom_data_setPv">
<span id="k_thread_custom_data_set__voidP"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga4834d9b81ed60c00eee77b0d4f8ab9e4"></span>void <code class="descclassname"></code><code class="descname">k_thread_custom_data_set</code><span class="sig-paren">(</span>void *<em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set current thread&#8217;s custom data. </p>
<p>This routine sets the custom data for the current thread to &#64; value.</p>
<p>Custom data is not used by the kernel itself, and is freely available for a thread to use as it sees fit. It can be used as a framework upon which to build thread-local storage.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">value</span></code>: New custom data value.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224k_thread_custom_data_getv">
<span id="k_thread_custom_data_get__void"></span><span class="target" id="Zephyrd6/de7/group__thread__apis_1ga8a53350c009f408fdfcd5002437132ba"></span>void *<code class="descclassname"></code><code class="descname">k_thread_custom_data_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Get current thread&#8217;s custom data. </p>
<p>This routine returns the custom data for the current thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current custom data value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_ESSENTIAL">
<span class="target" id="Zephyrd6/de7/group__thread__apis_1gad503fbcca905a9266b0e154e3ded258c"></span><code class="descname">K_ESSENTIAL</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.K_THREAD_DEFINE">
<span class="target" id="Zephyrd6/de7/group__thread__apis_1ga17a868cd8644dde6d0b5ea42fd4bb82f"></span><code class="descname">K_THREAD_DEFINE</code><span class="sig-paren">(</span>name, stack_size, entry, p1, p2, p3, prio, options, delay<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a thread. </p>
<p>The thread may be scheduled for immediate execution or a delayed start.</p>
<p>Thread options are architecture-specific, and can include K_ESSENTIAL, K_FP_REGS, and K_SSE_REGS. Multiple options may be specified by separating them using &#8220;|&#8221; (the logical OR operator).</p>
<p>The ID of the thread can be accessed using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">const</span> <span class="n">k_tid_t</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the thread. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Thread entry function. </li>
<li><code class="docutils literal"><span class="pre">p1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">p3</span></code>: 3rd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Thread priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Thread options. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Scheduling delay (in milliseconds), or K_NO_WAIT (for no delay). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="workqueues">
<h2><a class="toc-backref" href="#contents">Workqueues</a></h2>
<p>A workqueue processes a series of work items by executing the associated
functions in a dedicated thread. Workqueues are typically used by an ISR
or high-priority thread to offload non-urgent processing.
(See <a class="reference internal" href="../kernel/threads/workqueues.html#workqueues-v2"><span class="std std-ref">Workqueue Threads</span></a>.)</p>
<dl class="type">
<dt id="_CPPv216k_work_handler_t">
<span id="k_work_handler_t"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gaf94f1a715b671c9de978ec277b911a50"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">k_work_handler_t</code><br /></dt>
<dd><p>Work item handler function type. </p>
<p>A work item&#8217;s handler function is executed by a workqueue&#8217;s thread when the work item is processed by the workqueue.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of the work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_work_initP6k_work16k_work_handler_t">
<span id="k_work_init__k_workP.k_work_handler_t"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga5d448863f7f12300474d83713d035d0d"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">k_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em>, <a class="reference internal" href="#_CPPv216k_work_handler_t" title="k_work_handler_t">k_work_handler_t</a> <em>handler</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a work item. </p>
<p>This routine initializes a workqueue work item, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Function to invoke each time work item is processed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222k_work_submit_to_queueP8k_work_qP6k_work">
<span id="k_work_submit_to_queue__k_work_qP.k_workP"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gad8770c635132bf516a6b021464f51e1d"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">k_work_submit_to_queue</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, <em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a work item. </p>
<p>This routine submits work item <em>work</em> to be processed by workqueue <em>work_q</em>. If the work item is already pending in the workqueue&#8217;s queue as a result of an earlier submission, this routine has no effect on the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>A submitted work item must not be modified until it has been processed by the workqueue.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_work_pendingP6k_work">
<span id="k_work_pending__k_workP"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gac44ae7f3b602c0b51e22b37dd6c8dd64"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">k_work_pending</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Check if a work item is pending. </p>
<p>This routine indicates if work item <em>work</em> is pending in a workqueue&#8217;s queue.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>1 if work item is pending, or 0 if it is not pending. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_work_q_startP8k_work_qPc6size_ti">
<span id="k_work_q_start__k_work_qP.cP.s.i"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gac4e9932b6924152ce400786bc9bcd369"></span>void <code class="descclassname"></code><code class="descname">k_work_q_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, char *<em>stack</em>, size_t <em>stack_size</em>, int <em>prio</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a workqueue. </p>
<p>This routine starts workqueue <em>work_q</em>. The workqueue spawns its work processing thread, which runs forever.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to work queue thread&#8217;s stack space. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Size of the work queue thread&#8217;s stack (in bytes). </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Priority of the work queue&#8217;s thread.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_delayed_work_initP14k_delayed_work16k_work_handler_t">
<span id="k_delayed_work_init__k_delayed_workP.k_work_handler_t"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gabc1ae700058df16c6a280c9f682caacd"></span>void <code class="descclassname"></code><code class="descname">k_delayed_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em>, <a class="reference internal" href="#_CPPv216k_work_handler_t" title="k_work_handler_t">k_work_handler_t</a> <em>handler</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a delayed work item. </p>
<p>This routine initializes a workqueue delayed work item, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Function to invoke each time work item is processed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv230k_delayed_work_submit_to_queueP8k_work_qP14k_delayed_work7int32_t">
<span id="k_delayed_work_submit_to_queue__k_work_qP.k_delayed_workP.int32_t"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga4b1ba004ed35af3efb54eed8f1dd1b34"></span>int <code class="descclassname"></code><code class="descname">k_delayed_work_submit_to_queue</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>work_q</em>, <em class="property">struct</em> k_delayed_work *<em>work</em>, int32_t <em>delay</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a delayed work item. </p>
<p>This routine schedules work item <em>work</em> to be processed by workqueue <em>work_q</em> after a delay of <em>delay</em> milliseconds. The routine initiates an asychronous countdown for the work item and then returns to the caller. Only when the countdown completes is the work item actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted delayed work item that is still counting down cancels the existing submission and restarts the countdown using the new delay. If the work item is currently pending on the workqueue&#8217;s queue because the countdown has completed it is too late to resubmit the item, and resubmission fails without impacting the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>A delayed work item must not be modified until it has been processed by the workqueue.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_q</span></code>: Address of workqueue. </li>
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Delay before submitting the work item (in milliseconds).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown started. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
<li><code class="docutils literal"><span class="pre">-EADDRINUSE</span></code>: Work item is pending on a different workqueue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_delayed_work_cancelP14k_delayed_work">
<span id="k_delayed_work_cancel__k_delayed_workP"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga4a5d22d1317f77e1e5a61c7ddc314183"></span>int <code class="descclassname"></code><code class="descname">k_delayed_work_cancel</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Cancel a delayed work item. </p>
<p>This routine cancels the submission of delayed work item <em>work</em>. A delayed work item can only be cancelled while its countdown is still underway.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown cancelled. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_work_submitP6k_work">
<span id="k_work_submit__k_workP"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1gaef687f4052ee80cb24e4c5e1bb8512c3"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">k_work_submit</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a work item to the system workqueue. </p>
<p>This routine submits work item <em>work</em> to be processed by the system workqueue. If the work item is already pending in the workqueue&#8217;s queue as a result of an earlier submission, this routine has no effect on the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Work items submitted to the system workqueue should avoid using handlers that block or yield since this may prevent the system workqueue from processing other work items in a timely manner.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_delayed_work_submitP14k_delayed_work7int32_t">
<span id="k_delayed_work_submit__k_delayed_workP.int32_t"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga1b7a19678437cc68a956cec03dfe98ee"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">k_delayed_work_submit</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em>, int32_t <em>delay</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a delayed work item to the system workqueue. </p>
<p>This routine schedules work item <em>work</em> to be processed by the system workqueue after a delay of <em>delay</em> milliseconds. The routine initiates an asychronous countdown for the work item and then returns to the caller. Only when the countdown completes is the work item actually submitted to the workqueue and becomes pending.</p>
<p>Submitting a previously submitted delayed work item that is still counting down cancels the existing submission and restarts the countdown using the new delay. If the work item is currently pending on the workqueue&#8217;s queue because the countdown has completed it is too late to resubmit the item, and resubmission fails without impacting the work item. If the work item has already been processed, or is currently being processed, its work is considered complete and the work item can be resubmitted.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Work items submitted to the system workqueue should avoid using handlers that block or yield since this may prevent the system workqueue from processing other work items in a timely manner.</dd>
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Address of delayed work item. </li>
<li><code class="docutils literal"><span class="pre">delay</span></code>: Delay before submitting the work item (in milliseconds).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Work item countdown started. </li>
<li><code class="docutils literal"><span class="pre">-EINPROGRESS</span></code>: Work item is already pending. </li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: Work item is being processed or has completed its work. </li>
<li><code class="docutils literal"><span class="pre">-EADDRINUSE</span></code>: Work item is pending on a different workqueue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv228k_delayed_work_remaining_getP14k_delayed_work">
<span id="k_delayed_work_remaining_get__k_delayed_workP"></span><span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga3c5c9af0fb7c0518a87e04f110c27105"></span><em class="property">static</em> int32_t <code class="descclassname"></code><code class="descname">k_delayed_work_remaining_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_delayed_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get time remaining before a delayed work gets scheduled. </p>
<p>This routine computes the (approximate) time remaining before a delayed work gets executed. If the delayed work is not waiting to be schedules, it returns zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Remaining time (in milliseconds). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Delayed work item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_WORK_INITIALIZER">
<span class="target" id="Zephyrdc/d1c/group__workqueue__apis_1ga3763867e8c624b31768c7394922becb7"></span><code class="descname">K_WORK_INITIALIZER</code><span class="sig-paren">(</span>work_handler<span class="sig-paren">)</span></dt>
<dd><p>Initialize a statically-defined work item. </p>
<p>This macro can be used to initialize a statically-defined workqueue work item, prior to its first use. For example,</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">k_work</span> <span class="o">&lt;</span><span class="n">work</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">K_WORK_INITIALIZER</span><span class="p">(</span><span class="o">&lt;</span><span class="n">work_handler</span><span class="o">&gt;</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work_handler</span></code>: Function to invoke each time work item is processed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="clocks">
<h2><a class="toc-backref" href="#contents">Clocks</a></h2>
<p>Kernel clocks enable threads and ISRs to measure the passage of time
with either normal and high precision.
(See <a class="reference internal" href="../kernel/timing/clocks.html#clocks-v2"><span class="std std-ref">Kernel Clocks</span></a>.)</p>
<dl class="function">
<dt id="_CPPv212k_uptime_getv">
<span id="k_uptime_get__void"></span><span class="target" id="Zephyrde/dca/group__clock__apis_1gaa453111c1f12b2412db3be951e11b31d"></span>int64_t <code class="descclassname"></code><code class="descname">k_uptime_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Get system uptime. </p>
<p>This routine returns the elapsed time since the system booted, in milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current uptime. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_uptime_get_32v">
<span id="k_uptime_get_32__void"></span><span class="target" id="Zephyrde/dca/group__clock__apis_1gaf2779b4491293794d3d891c3745a15ba"></span>uint32_t <code class="descclassname"></code><code class="descname">k_uptime_get_32</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Get system uptime (32-bit version). </p>
<p>This routine returns the lower 32-bits of the elapsed time since the system booted, in milliseconds.</p>
<p>This routine can be more efficient than k_uptime_get(), as it reduces the need for interrupt locking and 64-bit math. However, the 32-bit result cannot hold a system uptime time larger than approximately 50 days, so the caller must handle possible rollovers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current uptime. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_uptime_deltaP7int64_t">
<span id="k_uptime_delta__int64_tP"></span><span class="target" id="Zephyrde/dca/group__clock__apis_1ga0ff6acc3d8fd17405d994eeb16bb4e5e"></span>int64_t <code class="descclassname"></code><code class="descname">k_uptime_delta</code><span class="sig-paren">(</span>int64_t *<em>reftime</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get elapsed time. </p>
<p>This routine computes the elapsed time between the current system uptime and an earlier reference time, in milliseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Elapsed time. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Pointer to a reference time, which is updated to the current uptime upon return.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217k_uptime_delta_32P7int64_t">
<span id="k_uptime_delta_32__int64_tP"></span><span class="target" id="Zephyrde/dca/group__clock__apis_1gad5adb4bc40e28b335cb9d2eee588ae98"></span>uint32_t <code class="descclassname"></code><code class="descname">k_uptime_delta_32</code><span class="sig-paren">(</span>int64_t *<em>reftime</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get elapsed time (32-bit version). </p>
<p>This routine computes the elapsed time between the current system uptime and an earlier reference time, in milliseconds.</p>
<p>This routine can be more efficient than k_uptime_delta(), as it reduces the need for interrupt locking and 64-bit math. However, the 32-bit result cannot hold an elapsed time larger than approximately 50 days, so the caller must handle possible rollovers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Elapsed time. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Pointer to a reference time, which is updated to the current uptime upon return.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_cycle_get_32v">
<span id="k_cycle_get_32__void"></span><span class="target" id="Zephyrde/dca/group__clock__apis_1gad81e794eac00997189bd3b5754ac6511"></span>uint32_t <code class="descclassname"></code><code class="descname">k_cycle_get_32</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Read the hardware clock. </p>
<p>This routine returns the current time, as measured by the system&#8217;s hardware clock.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current hardware clock up-counter (in cycles). </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_NO_WAIT">
<span class="target" id="Zephyrde/dca/group__clock__apis_1ga3d9541cfe2e8395af66d186efa77362f"></span><code class="descname">K_NO_WAIT</code></dt>
<dd><p>Generate null timeout delay. </p>
<p>This macro generates a timeout delay that that instructs a kernel API not to wait if the requested operation cannot be performed immediately.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MSEC">
<span class="target" id="Zephyrde/dca/group__clock__apis_1gaabc05846a2148e80343931986255b801"></span><code class="descname">K_MSEC</code><span class="sig-paren">(</span>ms<span class="sig-paren">)</span></dt>
<dd><p>Generate timeout delay from milliseconds. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>ms</em> milliseconds to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ms</span></code>: Duration in milliseconds.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_SECONDS">
<span class="target" id="Zephyrde/dca/group__clock__apis_1ga59367cf5137e60d370a19a744f362d69"></span><code class="descname">K_SECONDS</code><span class="sig-paren">(</span>s<span class="sig-paren">)</span></dt>
<dd><p>Generate timeout delay from seconds. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>s</em> seconds to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">s</span></code>: Duration in seconds.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MINUTES">
<span class="target" id="Zephyrde/dca/group__clock__apis_1gad80e0726cd296ed84ba6734b606344ba"></span><code class="descname">K_MINUTES</code><span class="sig-paren">(</span>m<span class="sig-paren">)</span></dt>
<dd><p>Generate timeout delay from minutes. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>m</em> minutes to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">m</span></code>: Duration in minutes.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_HOURS">
<span class="target" id="Zephyrde/dca/group__clock__apis_1ga8fa9ba2112b5dfd6125e4f74c54e9835"></span><code class="descname">K_HOURS</code><span class="sig-paren">(</span>h<span class="sig-paren">)</span></dt>
<dd><p>Generate timeout delay from hours. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait up to <em>h</em> hours to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">h</span></code>: Duration in hours.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_FOREVER">
<span class="target" id="Zephyrde/dca/group__clock__apis_1ga0bb4b83f0222193b21a8910311bab0ca"></span><code class="descname">K_FOREVER</code></dt>
<dd><p>Generate infinite timeout delay. </p>
<p>This macro generates a timeout delay that that instructs a kernel API to wait as long as necessary to perform the requested operation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timeout delay value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_CLOCK_HW_CYCLES_TO_NS">
<span class="target" id="Zephyrde/dca/group__clock__apis_1ga60b80bbea58a354fd814ca16f1dd51ec"></span><code class="descname">SYS_CLOCK_HW_CYCLES_TO_NS</code><span class="sig-paren">(</span>X<span class="sig-paren">)</span></dt>
<dd><p>Compute nanoseconds from hardware clock cycles. </p>
<p>This macro converts a time duration expressed in hardware clock cycles to the equivalent duration expressed in nanoseconds.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Duration in nanoseconds. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">X</span></code>: Duration in hardware clock cycles.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="timers">
<h2><a class="toc-backref" href="#contents">Timers</a></h2>
<p>Timers enable threads to measure the passage of time, and to optionally execute
an action when the timer expires.
(See <a class="reference internal" href="../kernel/timing/timers.html#timers-v2"><span class="std std-ref">Timers</span></a>.)</p>
<dl class="type">
<dt id="_CPPv216k_timer_expiry_t">
<span id="k_timer_expiry_t"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga37bcd42a457855a68b74570c979ababa"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">k_timer_expiry_t</code><br /></dt>
<dd><p>Timer expiry function type. </p>
<p>A timer&#8217;s expiry function is executed by the system clock interrupt handler each time the timer expires. The expiry function is optional, and is only invoked if the timer has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv214k_timer_stop_t">
<span id="k_timer_stop_t"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga16fbd44c08a26c4fdeb7f542f2a03a15"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">k_timer_stop_t</code><br /></dt>
<dd><p>Timer stop function type. </p>
<p>A timer&#8217;s stop function is executed if the timer is stopped prematurely. The function runs in the context of the thread that stops the timer. The stop function is optional, and is only invoked if the timer has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_timer_initP7k_timer16k_timer_expiry_t14k_timer_stop_t">
<span id="k_timer_init__k_timerP.k_timer_expiry_t.k_timer_stop_t"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga318c846a740b901e5d56876a47ad7f61"></span>void <code class="descclassname"></code><code class="descname">k_timer_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, <a class="reference internal" href="#_CPPv216k_timer_expiry_t" title="k_timer_expiry_t">k_timer_expiry_t</a> <em>expiry_fn</em>, <a class="reference internal" href="#_CPPv214k_timer_stop_t" title="k_timer_stop_t">k_timer_stop_t</a> <em>stop_fn</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a timer. </p>
<p>This routine initializes a timer, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">expiry_fn</span></code>: Function to invoke each time the timer expires. </li>
<li><code class="docutils literal"><span class="pre">stop_fn</span></code>: Function to invoke if the timer is stopped while running.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213k_timer_startP7k_timer7int32_t7int32_t">
<span id="k_timer_start__k_timerP.int32_t.int32_t"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1gabf6293e860501a438c8e47bc2a7a6146"></span>void <code class="descclassname"></code><code class="descname">k_timer_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, int32_t <em>duration</em>, int32_t <em>period</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a timer. </p>
<p>This routine starts a timer, and resets its status to zero. The timer begins counting down using the specified duration and period values.</p>
<p>Attempting to start a timer that is already running is permitted. The timer&#8217;s status is reset to zero and the timer begins counting down using the new duration and period values.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">duration</span></code>: Initial timer duration (in milliseconds). </li>
<li><code class="docutils literal"><span class="pre">period</span></code>: Timer period (in milliseconds).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_timer_stopP7k_timer">
<span id="k_timer_stop__k_timerP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga8d3e3356a10d36570e16f7920e4c8772"></span>void <code class="descclassname"></code><code class="descname">k_timer_stop</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Stop a timer. </p>
<p>This routine stops a running timer prematurely. The timer&#8217;s stop function, if one exists, is invoked by the caller.</p>
<p>Attempting to stop a timer that is not running is permitted, but has no effect on the timer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218k_timer_status_getP7k_timer">
<span id="k_timer_status_get__k_timerP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1gad532f4834cd4cf8be27b089e6ea347ce"></span>uint32_t <code class="descclassname"></code><code class="descname">k_timer_status_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read timer status. </p>
<p>This routine reads the timer&#8217;s status, which indicates the number of times it has expired since its status was last read.</p>
<p>Calling this routine resets the timer&#8217;s status to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timer status. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_timer_status_syncP7k_timer">
<span id="k_timer_status_sync__k_timerP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga81d6d95b7021e26ad4cab161318e04f2"></span>uint32_t <code class="descclassname"></code><code class="descname">k_timer_status_sync</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Synchronize thread to timer expiration. </p>
<p>This routine blocks the calling thread until the timer&#8217;s status is non-zero (indicating that it has expired at least once since it was last examined) or the timer is stopped. If the timer status is already non-zero, or the timer is already stopped, the caller continues without waiting.</p>
<p>Calling this routine resets the timer&#8217;s status to zero.</p>
<p>This routine must not be used by interrupt handlers, since they are not allowed to block.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Timer status. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_remaining_getP7k_timer">
<span id="k_timer_remaining_get__k_timerP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga976067487906a2374a335270fdd5d335"></span><em class="property">static</em> int32_t <code class="descclassname"></code><code class="descname">k_timer_remaining_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get time remaining before a timer next expires. </p>
<p>This routine computes the (approximate) time remaining before a running timer next expires. If the timer is not running, it returns zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Remaining time (in milliseconds). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_user_data_setP7k_timerPv">
<span id="k_timer_user_data_set__k_timerP.voidP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1gae93eaf5cc38310acf67a87b971d789b2"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">k_timer_user_data_set</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, void *<em>user_data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Associate user-specific data with a timer. </p>
<p>This routine records the <em>user_data</em> with the <em>timer</em>, to be retrieved later.</p>
<p>It can be used e.g. in a timer handler shared across multiple subsystems to retrieve data specific to the subsystem this timer is associated with.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer. </li>
<li><code class="docutils literal"><span class="pre">user_data</span></code>: User data to associate with the timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_timer_user_data_getP7k_timer">
<span id="k_timer_user_data_get__k_timerP"></span><span class="target" id="Zephyrd0/d15/group__timer__apis_1ga96f855967648b2efeb0b2e38550774da"></span><em class="property">static</em> void *<code class="descclassname"></code><code class="descname">k_timer_user_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve the user-specific data from a timer. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The user data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Address of timer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_TIMER_DEFINE">
<span class="target" id="Zephyrd0/d15/group__timer__apis_1gaa267fcb0a2e18cd0da29e9f9612510a6"></span><code class="descname">K_TIMER_DEFINE</code><span class="sig-paren">(</span>name, expiry_fn, stop_fn<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a timer. </p>
<p>The timer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_timer</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the timer variable. </li>
<li><code class="docutils literal"><span class="pre">expiry_fn</span></code>: Function to invoke each time the timer expires. </li>
<li><code class="docutils literal"><span class="pre">stop_fn</span></code>: Function to invoke if the timer is stopped while running. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="memory-slabs">
<h2><a class="toc-backref" href="#contents">Memory Slabs</a></h2>
<p>Memory slabs enable the dynamic allocation and release of fixed-size
memory blocks.
(See <a class="reference internal" href="../kernel/memory/slabs.html#memory-slabs-v2"><span class="std std-ref">Memory Slabs</span></a>.)</p>
<dl class="function">
<dt id="_CPPv215k_mem_slab_initP10k_mem_slabPv6size_t8uint32_t">
<span id="k_mem_slab_init__k_mem_slabP.voidP.s.uint32_t"></span><span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1ga1f20dc88166ce425483613251a89b5e4"></span>void <code class="descclassname"></code><code class="descname">k_mem_slab_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void *<em>buffer</em>, size_t <em>block_size</em>, uint32_t <em>num_blocks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a memory slab. </p>
<p>Initializes a memory slab, prior to its first use.</p>
<p>The memory slab&#8217;s buffer contains <em>slab_num_blocks</em> memory blocks that are <em>slab_block_size</em> bytes long. The buffer must be aligned to an N-byte boundary, where N is a power of 2 larger than 2 (i.e. 4, 8, 16, ...). To ensure that each memory block is similarly aligned to this boundary, <em>slab_block_size</em> must also be a multiple of N.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Pointer to buffer used for the memory blocks. </li>
<li><code class="docutils literal"><span class="pre">block_size</span></code>: Size of each memory block (in bytes). </li>
<li><code class="docutils literal"><span class="pre">num_blocks</span></code>: Number of memory blocks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_mem_slab_allocP10k_mem_slabPPv7int32_t">
<span id="k_mem_slab_alloc__k_mem_slabP.voidPP.int32_t"></span><span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1ga463c60c19f9859bb48bace42e47ba210"></span>int <code class="descclassname"></code><code class="descname">k_mem_slab_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void **<em>mem</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory from a memory slab. </p>
<p>This routine allocates a memory block from a memory slab.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">mem</span></code>: Pointer to block address area. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Maximum time to wait for operation to complete (in milliseconds). Use K_NO_WAIT to return without waiting, or K_FOREVER to wait as long as necessary.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Memory allocated. The block address area pointed at by <em>mem</em> is set to the starting address of the memory block. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mem_slab_freeP10k_mem_slabPPv">
<span id="k_mem_slab_free__k_mem_slabP.voidPP"></span><span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1ga97915aee5a59e19f8b28185eed93aac7"></span>void <code class="descclassname"></code><code class="descname">k_mem_slab_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em>, void **<em>mem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free memory allocated from a memory slab. </p>
<p>This routine releases a previously allocated memory block back to its associated memory slab.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">mem</span></code>: Pointer to block address area (as set by k_mem_slab_alloc()).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223k_mem_slab_num_used_getP10k_mem_slab">
<span id="k_mem_slab_num_used_get__k_mem_slabP"></span><span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1gac76b96d7055e4ad94765c93530dd0720"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">k_mem_slab_num_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the number of used blocks in a memory slab. </p>
<p>This routine gets the number of memory blocks that are currently allocated in <em>slab</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of allocated memory blocks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223k_mem_slab_num_free_getP10k_mem_slab">
<span id="k_mem_slab_num_free_get__k_mem_slabP"></span><span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1gae87577e2873cf746db69216a82f94aea"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">k_mem_slab_num_free_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>slab</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the number of unused blocks in a memory slab. </p>
<p>This routine gets the number of memory blocks that are currently unallocated in <em>slab</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of unallocated memory blocks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">slab</span></code>: Address of the memory slab.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MEM_SLAB_DEFINE">
<span class="target" id="Zephyrd6/d4a/group__mem__slab__apis_1ga60bc92eee58fcc5f121b8e4d82eaa69e"></span><code class="descname">K_MEM_SLAB_DEFINE</code><span class="sig-paren">(</span>name, slab_block_size, slab_num_blocks, slab_align<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a memory slab. </p>
<p>The memory slab&#8217;s buffer contains <em>slab_num_blocks</em> memory blocks that are <em>slab_block_size</em> bytes long. The buffer is aligned to a <em>slab_align</em> -byte boundary. To ensure that each memory block is similarly aligned to this boundary, <em>slab_block_size</em> must also be a multiple of <em>slab_align</em>.</p>
<p>The memory slab can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mem_slab</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the memory slab. </li>
<li><code class="docutils literal"><span class="pre">slab_block_size</span></code>: Size of each memory block (in bytes). </li>
<li><code class="docutils literal"><span class="pre">slab_num_blocks</span></code>: Number memory blocks. </li>
<li><code class="docutils literal"><span class="pre">slab_align</span></code>: Alignment of the memory slab&#8217;s buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="memory-pools">
<h2><a class="toc-backref" href="#contents">Memory Pools</a></h2>
<p>Memory pools enable the dynamic allocation and release of variable-size
memory blocks.
(See <a class="reference internal" href="../kernel/memory/pools.html#memory-pools-v2"><span class="std std-ref">Memory Pools</span></a>.)</p>
<dl class="function">
<dt id="_CPPv216k_mem_pool_allocP10k_mem_poolP11k_mem_block6size_t7int32_t">
<span id="k_mem_pool_alloc__k_mem_poolP.k_mem_blockP.s.int32_t"></span><span class="target" id="Zephyrde/d82/group__mem__pool__apis_1gae7da8df5901dc4bad4eeb0e8439817b9"></span>int <code class="descclassname"></code><code class="descname">k_mem_pool_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_pool *<em>pool</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, size_t <em>size</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory from a memory pool. </p>
<p>This routine allocates a memory block from a memory pool.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pool</span></code>: Address of the memory pool. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Pointer to block descriptor for the allocated memory. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Amount of memory to allocate (in bytes). </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Maximum time to wait for operation to complete (in milliseconds). Use K_NO_WAIT to return without waiting, or K_FOREVER to wait as long as necessary.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Memory allocated. The <em>data</em> field of the block descriptor is set to the starting address of the memory block. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mem_pool_freeP11k_mem_block">
<span id="k_mem_pool_free__k_mem_blockP"></span><span class="target" id="Zephyrde/d82/group__mem__pool__apis_1ga959cbc76f729ffe5842bf6b2d40c6f8b"></span>void <code class="descclassname"></code><code class="descname">k_mem_pool_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_block *<em>block</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free memory allocated from a memory pool. </p>
<p>This routine releases a previously allocated memory block back to its memory pool.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">block</span></code>: Pointer to block descriptor for the allocated memory.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217k_mem_pool_defragP10k_mem_pool">
<span id="k_mem_pool_defrag__k_mem_poolP"></span><span class="target" id="Zephyrde/d82/group__mem__pool__apis_1ga4cd58321b7b84a7ac0cb548bf0c75baf"></span>void <code class="descclassname"></code><code class="descname">k_mem_pool_defrag</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_pool *<em>pool</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Defragment a memory pool. </p>
<p>This routine instructs a memory pool to concatenate unused memory blocks into larger blocks wherever possible. Manually defragmenting the memory pool may speed up future allocations of memory blocks by eliminating the need for the memory pool to perform an automatic partial defragmentation.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pool</span></code>: Address of the memory pool.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MEM_POOL_DEFINE">
<span class="target" id="Zephyrde/d82/group__mem__pool__apis_1ga53c7a72df873275c67aff4a0049ba47a"></span><code class="descname">K_MEM_POOL_DEFINE</code><span class="sig-paren">(</span>name, min_size, max_size, n_max, align<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a memory pool. </p>
<p>The memory pool&#8217;s buffer contains <em>n_max</em> blocks that are <em>max_size</em> bytes long. The memory pool allows blocks to be repeatedly partitioned into quarters, down to blocks of <em>min_size</em> bytes long. The buffer is aligned to a <em>align</em> -byte boundary. To ensure that the minimum sized blocks are similarly aligned to this boundary, <em>min_size</em> must also be a multiple of <em>align</em>.</p>
<p>If the pool is to be accessed outside the module where it is defined, it can be declared via</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mem_pool</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the memory pool. </li>
<li><code class="docutils literal"><span class="pre">min_size</span></code>: Size of the smallest blocks in the pool (in bytes). </li>
<li><code class="docutils literal"><span class="pre">max_size</span></code>: Size of the largest blocks in the pool (in bytes). </li>
<li><code class="docutils literal"><span class="pre">n_max</span></code>: Number of maximum sized blocks in the pool. </li>
<li><code class="docutils literal"><span class="pre">align</span></code>: Alignment of the pool&#8217;s buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="heap-memory-pool">
<h2><a class="toc-backref" href="#contents">Heap Memory Pool</a></h2>
<p>The heap memory pools enable the dynamic allocation and release of memory
in a <code class="xref cpp cpp-func docutils literal"><span class="pre">malloc()</span></code>-like manner.
(See <a class="reference internal" href="../kernel/memory/heap.html#heap-v2"><span class="std std-ref">Heap Memory Pool</span></a>.)</p>
<dl class="function">
<dt id="_CPPv28k_malloc6size_t">
<span id="k_malloc__s"></span><span class="target" id="Zephyrdb/d30/group__heap__apis_1gaee4557c0eeb6d2f97fc3715d91742e10"></span>void *<code class="descclassname"></code><code class="descname">k_malloc</code><span class="sig-paren">(</span>size_t <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory from heap. </p>
<p>This routine provides traditional malloc() semantics. Memory is allocated from the heap memory pool.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Address of the allocated memory if successful; otherwise NULL. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">size</span></code>: Amount of memory requested (in bytes).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv26k_freePv">
<span id="k_free__voidP"></span><span class="target" id="Zephyrdb/d30/group__heap__apis_1ga79b63cc93b3358cf82d74f40e73b69d5"></span>void <code class="descclassname"></code><code class="descname">k_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free memory allocated from heap. </p>
<p>This routine provides traditional free() semantics. The memory being returned must have been allocated from the heap memory pool.</p>
<p>If <em>ptr</em> is NULL, no operation is performed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ptr</span></code>: Pointer to previously allocated memory.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="semaphores">
<h2><a class="toc-backref" href="#contents">Semaphores</a></h2>
<p>Semaphores provide traditional counting semaphore capabilities.
(See <a class="reference internal" href="../kernel/synchronization/semaphores.html#semaphores-v2"><span class="std std-ref">Semaphores</span></a>.)</p>
<dl class="function">
<dt id="_CPPv210k_sem_initP5k_semjj">
<span id="k_sem_init__k_semP.unsigned-i.unsigned-i"></span><span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1gabcc4bc6fb64a1f29a9d5683ea42255ce"></span>void <code class="descclassname"></code><code class="descname">k_sem_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, unsigned int <em>initial_count</em>, unsigned int <em>limit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a semaphore. </p>
<p>This routine initializes a semaphore object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">initial_count</span></code>: Initial semaphore count. </li>
<li><code class="docutils literal"><span class="pre">limit</span></code>: Maximum permitted semaphore count.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_sem_takeP5k_sem7int32_t">
<span id="k_sem_take__k_semP.int32_t"></span><span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1ga22e5c8ad07f4f8b7cfcf26c7f8cd6e21"></span>int <code class="descclassname"></code><code class="descname">k_sem_take</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Take a semaphore. </p>
<p>This routine takes <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Note</strong></dt>
<dd>When porting code from the nanokernel legacy API to the new API, be careful with the return value of this function. The return value is the reverse of the one of nano_sem_take family of APIs: 0 means success, and non-zero means failure, while the nano_sem_take family returns 1 for success and 0 for failure.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to take the semaphore (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Semaphore taken. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_sem_giveP5k_sem">
<span id="k_sem_give__k_semP"></span><span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1gab9be3cf1988af2cd6afdace52d497c84"></span>void <code class="descclassname"></code><code class="descname">k_sem_give</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Give a semaphore. </p>
<p>This routine gives <em>sem</em>, unless the semaphore is already at its maximum permitted count.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_sem_resetP5k_sem">
<span id="k_sem_reset__k_semP"></span><span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1ga6a0f0d2cb0cad036344a414a3eebcf97"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">k_sem_reset</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Reset a semaphore&#8217;s count to zero. </p>
<p>This routine sets the count of <em>sem</em> to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_sem_count_getP5k_sem">
<span id="k_sem_count_get__k_semP"></span><span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1ga2db97d966b4fe4358236b2a35ec6fff4"></span><em class="property">static</em> unsigned int <code class="descclassname"></code><code class="descname">k_sem_count_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get a semaphore&#8217;s count. </p>
<p>This routine returns the current count of <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Current semaphore count. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of the semaphore.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_SEM_DEFINE">
<span class="target" id="Zephyrd6/d5e/group__semaphore__apis_1ga018a8aa43e02e704deee7b6341502946"></span><code class="descname">K_SEM_DEFINE</code><span class="sig-paren">(</span>name, initial_count, count_limit<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a semaphore. </p>
<p>The semaphore can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_sem</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the semaphore. </li>
<li><code class="docutils literal"><span class="pre">initial_count</span></code>: Initial semaphore count. </li>
<li><code class="docutils literal"><span class="pre">count_limit</span></code>: Maximum permitted semaphore count. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="mutexes">
<h2><a class="toc-backref" href="#contents">Mutexes</a></h2>
<p>Mutexes provide traditional reentrant mutex capabilities
with basic priority inheritance.
(See <a class="reference internal" href="../kernel/synchronization/mutexes.html#mutexes-v2"><span class="std std-ref">Mutexes</span></a>.)</p>
<dl class="function">
<dt id="_CPPv212k_mutex_initP7k_mutex">
<span id="k_mutex_init__k_mutexP"></span><span class="target" id="Zephyrd0/dc1/group__mutex__apis_1gaafc58c512a6a388629a09816cbdeebdf"></span>void <code class="descclassname"></code><code class="descname">k_mutex_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a mutex. </p>
<p>This routine initializes a mutex object, prior to its first use.</p>
<p>Upon completion, the mutex is available and does not have an owner.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_mutex_lockP7k_mutex7int32_t">
<span id="k_mutex_lock__k_mutexP.int32_t"></span><span class="target" id="Zephyrd0/dc1/group__mutex__apis_1gacd940a43ab4e169ed824428c2105aa57"></span>int <code class="descclassname"></code><code class="descname">k_mutex_lock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Lock a mutex. </p>
<p>This routine locks <em>mutex</em>. If the mutex is locked by another thread, the calling thread waits until the mutex becomes available or until a timeout occurs.</p>
<p>A thread is permitted to lock a mutex it has already locked. The operation completes immediately and the lock count is increased by 1.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to lock the mutex (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Mutex locked. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214k_mutex_unlockP7k_mutex">
<span id="k_mutex_unlock__k_mutexP"></span><span class="target" id="Zephyrd0/dc1/group__mutex__apis_1gabe098971b5dac0a28dd1582e3b8eb0ef"></span>void <code class="descclassname"></code><code class="descname">k_mutex_unlock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Unlock a mutex. </p>
<p>This routine unlocks <em>mutex</em>. The mutex must already be locked by the calling thread.</p>
<p>The mutex cannot be claimed by another thread until it has been unlocked by the calling thread as many times as it was previously locked by that thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Address of the mutex.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MUTEX_DEFINE">
<span class="target" id="Zephyrd0/dc1/group__mutex__apis_1gab6f3d98fabbdc0918bbc9934d61d63f3"></span><code class="descname">K_MUTEX_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a mutex. </p>
<p>The mutex can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mutex</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the mutex. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="alerts">
<h2><a class="toc-backref" href="#contents">Alerts</a></h2>
<p>Alerts enable an application to perform asynchronous signalling,
somewhat akin to Unix-style signals.
(See <a class="reference internal" href="../kernel/synchronization/alerts.html#alerts-v2"><span class="std std-ref">Alerts</span></a>.)</p>
<dl class="type">
<dt id="_CPPv217k_alert_handler_t">
<span id="k_alert_handler_t"></span><span class="target" id="Zephyrd4/d28/group__alert__apis_1ga93cefa21ba46f6b2c13c3800af3bb961"></span><em class="property">typedef </em><code class="descclassname"></code><code class="descname">k_alert_handler_t</code><br /></dt>
<dd><p>Alert handler function type. </p>
<p>An alert&#8217;s alert handler function is invoked by the system workqueue when the alert is signalled. The alert handler function is optional, and is only invoked if the alert has been initialized with one.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>0 if alert has been consumed; non-zero if alert should pend. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_alert_initP7k_alert17k_alert_handler_tj">
<span id="k_alert_init__k_alertP.k_alert_handler_t.unsigned-i"></span><span class="target" id="Zephyrd4/d28/group__alert__apis_1gaf34f53d18d71b9518f337eebbd7ae05b"></span>void <code class="descclassname"></code><code class="descname">k_alert_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em>, <a class="reference internal" href="#_CPPv217k_alert_handler_t" title="k_alert_handler_t">k_alert_handler_t</a> <em>handler</em>, unsigned int <em>max_num_pending_alerts</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize an alert. </p>
<p>This routine initializes an alert object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Action to take when alert is sent. Specify either the address of a function to be invoked by the system workqueue thread, K_ALERT_IGNORE (which causes the alert to be ignored), or K_ALERT_DEFAULT (which causes the alert to pend). </li>
<li><code class="docutils literal"><span class="pre">max_num_pending_alerts</span></code>: Maximum number of pending alerts.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_alert_recvP7k_alert7int32_t">
<span id="k_alert_recv__k_alertP.int32_t"></span><span class="target" id="Zephyrd4/d28/group__alert__apis_1ga56c09ff4143ee2a4c94fe7256081dfd8"></span>int <code class="descclassname"></code><code class="descname">k_alert_recv</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Receive an alert. </p>
<p>This routine receives a pending alert for <em>alert</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to receive the alert (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Alert received. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_alert_sendP7k_alert">
<span id="k_alert_send__k_alertP"></span><span class="target" id="Zephyrd4/d28/group__alert__apis_1gac9e00523e612aa28b834b9e192bc7f96"></span>void <code class="descclassname"></code><code class="descname">k_alert_send</code><span class="sig-paren">(</span><em class="property">struct</em> k_alert *<em>alert</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Signal an alert. </p>
<p>This routine signals <em>alert</em>. The action specified for <em>alert</em> will be taken, which may trigger the execution of an alert handler function and/or cause the alert to pend (assuming the alert has not reached its maximum number of pending alerts).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">alert</span></code>: Address of the alert.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_ALERT_DEFINE">
<span class="target" id="Zephyrd4/d28/group__alert__apis_1ga168bcb820df2cb1e72c7eeb697322f33"></span><code class="descname">K_ALERT_DEFINE</code><span class="sig-paren">(</span>name, alert_handler, max_num_pending_alerts<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize an alert. </p>
<p>The alert can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_alert</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the alert. </li>
<li><code class="docutils literal"><span class="pre">alert_handler</span></code>: Action to take when alert is sent. Specify either the address of a function to be invoked by the system workqueue thread, K_ALERT_IGNORE (which causes the alert to be ignored), or K_ALERT_DEFAULT (which causes the alert to pend). </li>
<li><code class="docutils literal"><span class="pre">max_num_pending_alerts</span></code>: Maximum number of pending alerts. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="fifos">
<h2><a class="toc-backref" href="#contents">Fifos</a></h2>
<p>Fifos provide traditional first in, first out (FIFO) queuing of data items
of any size.
(See <a class="reference internal" href="../kernel/data_passing/fifos.html#fifos-v2"><span class="std std-ref">Fifos</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_fifo_initP6k_fifo">
<span id="k_fifo_init__k_fifoP"></span><span class="target" id="Zephyrd2/dbb/group__fifo__apis_1gab0584cdb8790053b441514b0716ec3a1"></span>void <code class="descclassname"></code><code class="descname">k_fifo_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a fifo. </p>
<p>This routine initializes a fifo object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_fifo_putP6k_fifoPv">
<span id="k_fifo_put__k_fifoP.voidP"></span><span class="target" id="Zephyrd2/dbb/group__fifo__apis_1gabb05a17ab0daa0d69efc4f60d82c5806"></span>void <code class="descclassname"></code><code class="descname">k_fifo_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, void *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add an element to a fifo. </p>
<p>This routine adds a data item to <em>fifo</em>. A fifo data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel&#8217;s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_fifo_put_listP6k_fifoPvPv">
<span id="k_fifo_put_list__k_fifoP.voidP.voidP"></span><span class="target" id="Zephyrd2/dbb/group__fifo__apis_1ga87630d23a5d1af19006a90895b5f9e80"></span>void <code class="descclassname"></code><code class="descname">k_fifo_put_list</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, void *<em>head</em>, void *<em>tail</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically add a list of elements to a fifo. </p>
<p>This routine adds a list of data items to <em>fifo</em> in one operation. The data items must be in a singly-linked list, with the first 32 bits each data item pointing to the next data item; the list must be NULL-terminated.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">head</span></code>: Pointer to first node in singly-linked list. </li>
<li><code class="docutils literal"><span class="pre">tail</span></code>: Pointer to last node in singly-linked list.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_fifo_put_slistP6k_fifoP11sys_slist_t">
<span id="k_fifo_put_slist__k_fifoP.sys_slist_tP"></span><span class="target" id="Zephyrd2/dbb/group__fifo__apis_1ga914b936b7098b2f128d8b1068435ce86"></span>void <code class="descclassname"></code><code class="descname">k_fifo_put_slist</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, sys_slist_t *<em>list</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically add a list of elements to a fifo. </p>
<p>This routine adds a list of data items to <em>fifo</em> in one operation. The data items must be in a singly-linked list implemented using a sys_slist_t object. Upon completion, the sys_slist_t object is invalid and must be re-initialized via sys_slist_init().</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">list</span></code>: Pointer to sys_slist_t object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_fifo_getP6k_fifo7int32_t">
<span id="k_fifo_get__k_fifoP.int32_t"></span><span class="target" id="Zephyrd2/dbb/group__fifo__apis_1gac924298f115a2091f6bf06d320189070"></span>void *<code class="descclassname"></code><code class="descname">k_fifo_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get an element from a fifo. </p>
<p>This routine removes a data item from <em>fifo</em> in a &#8220;first in, first out&#8221; manner. The first 32 bits of the data item are reserved for the kernel&#8217;s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Return</strong></dt>
<dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: Address of the fifo. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a data item (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_FIFO_DEFINE">
<span class="target" id="Zephyrd2/dbb/group__fifo__apis_1ga230b02a526ecb0ae1598be75cb9a8274"></span><code class="descname">K_FIFO_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a fifo. </p>
<p>The fifo can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_fifo</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the fifo. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="lifos">
<h2><a class="toc-backref" href="#contents">Lifos</a></h2>
<p>Lifos provide traditional last in, first out (LIFO) queuing of data items
of any size.
(See <a class="reference internal" href="../kernel/data_passing/lifos.html#lifos-v2"><span class="std std-ref">Lifos</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_lifo_initP6k_lifo">
<span id="k_lifo_init__k_lifoP"></span><span class="target" id="Zephyrd8/d92/group__lifo__apis_1ga0328fae40b9b022dd709bfe2cd194d14"></span>void <code class="descclassname"></code><code class="descname">k_lifo_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a lifo. </p>
<p>This routine initializes a lifo object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_lifo_putP6k_lifoPv">
<span id="k_lifo_put__k_lifoP.voidP"></span><span class="target" id="Zephyrd8/d92/group__lifo__apis_1ga8f5ab5bdb971d5f3ebdf740d01de860b"></span>void <code class="descclassname"></code><code class="descname">k_lifo_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em>, void *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add an element to a lifo. </p>
<p>This routine adds a data item to <em>lifo</em>. A lifo data item must be aligned on a 4-byte boundary, and the first 32 bits of the item are reserved for the kernel&#8217;s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of the data item.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_lifo_getP6k_lifo7int32_t">
<span id="k_lifo_get__k_lifoP.int32_t"></span><span class="target" id="Zephyrd8/d92/group__lifo__apis_1ga8b63b9ee7864df675153a6c1c1968728"></span>void *<code class="descclassname"></code><code class="descname">k_lifo_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get an element from a lifo. </p>
<p>This routine removes a data item from <em>lifo</em> in a &#8220;last in, first out&#8221; manner. The first 32 bits of the data item are reserved for the kernel&#8217;s use.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Return</strong></dt>
<dd>Address of the data item if successful; NULL if returned without waiting, or waiting period timed out. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: Address of the lifo. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a data item (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_LIFO_DEFINE">
<span class="target" id="Zephyrd8/d92/group__lifo__apis_1gaebd450d4181f22491623ea0aed6ee576"></span><code class="descname">K_LIFO_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a lifo. </p>
<p>The lifo can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_lifo</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the fifo. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="stacks">
<h2><a class="toc-backref" href="#contents">Stacks</a></h2>
<p>Stacks provide traditional last in, first out (LIFO) queuing of 32-bit
data items.
(See <a class="reference internal" href="../kernel/data_passing/stacks.html#stacks-v2"><span class="std std-ref">Stacks</span></a>.)</p>
<dl class="function">
<dt id="_CPPv212k_stack_initP7k_stackP8uint32_ti">
<span id="k_stack_init__k_stackP.uint32_tP.i"></span><span class="target" id="Zephyrdc/d17/group__stack__apis_1ga85d87c7e702821b9ed264c9b710836b4"></span>void <code class="descclassname"></code><code class="descname">k_stack_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t *<em>buffer</em>, int <em>num_entries</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a stack. </p>
<p>This routine initializes a stack object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of array used to hold stacked values. </li>
<li><code class="docutils literal"><span class="pre">num_entries</span></code>: Maximum number of values that can be stacked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_stack_pushP7k_stack8uint32_t">
<span id="k_stack_push__k_stackP.uint32_t"></span><span class="target" id="Zephyrdc/d17/group__stack__apis_1ga5f491b8961522e3f4df15b4ada479c3c"></span>void <code class="descclassname"></code><code class="descname">k_stack_push</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t <em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Push an element onto a stack. </p>
<p>This routine adds a 32-bit value <em>data</em> to <em>stack</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Value to push onto the stack.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211k_stack_popP7k_stackP8uint32_t7int32_t">
<span id="k_stack_pop__k_stackP.uint32_tP.int32_t"></span><span class="target" id="Zephyrdc/d17/group__stack__apis_1ga513f3a46f9d62cddec6d506f6aacbc9c"></span>int <code class="descclassname"></code><code class="descname">k_stack_pop</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t *<em>data</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Pop an element from a stack. </p>
<p>This routine removes a 32-bit value from <em>stack</em> in a &#8220;last in, first out&#8221; manner and stores the value in <em>data</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Address of the stack. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of area to hold the value popped from the stack. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to obtain a value (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Element popped from stack. </li>
<li><code class="docutils literal"><span class="pre">-EBUSY</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_STACK_DEFINE">
<span class="target" id="Zephyrdc/d17/group__stack__apis_1ga4d44605e1e6d51626564a9a289cd809b"></span><code class="descname">K_STACK_DEFINE</code><span class="sig-paren">(</span>name, stack_num_entries<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a stack. </p>
<p>The stack can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_stack</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the stack. </li>
<li><code class="docutils literal"><span class="pre">stack_num_entries</span></code>: Maximum number of values that can be stacked. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="message-queues">
<h2><a class="toc-backref" href="#contents">Message Queues</a></h2>
<p>Message queues provide a simple message queuing mechanism
for fixed-size data items.
(See <a class="reference internal" href="../kernel/data_passing/message_queues.html#message-queues-v2"><span class="std std-ref">Message Queues</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_msgq_initP6k_msgqPc6size_t8uint32_t">
<span id="k_msgq_init__k_msgqP.cP.s.uint32_t"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1ga80cb9263aef57d34e1239e64c8e78b11"></span>void <code class="descclassname"></code><code class="descname">k_msgq_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, char *<em>buffer</em>, size_t <em>msg_size</em>, uint32_t <em>max_msgs</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a message queue. </p>
<p>This routine initializes a message queue object, prior to its first use.</p>
<p>The message queue&#8217;s ring buffer must contain space for <em>max_msgs</em> messages, each of which is <em>msg_size</em> bytes long. The buffer must be aligned to an N-byte boundary, where N is a power of 2 (i.e. 1, 2, 4, ...). To ensure that each message is similarly aligned to this boundary, <em>q_msg_size</em> must also be a multiple of N.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Pointer to ring buffer that holds queued messages. </li>
<li><code class="docutils literal"><span class="pre">msg_size</span></code>: Message size (in bytes). </li>
<li><code class="docutils literal"><span class="pre">max_msgs</span></code>: Maximum number of messages that can be queued.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_msgq_putP6k_msgqPv7int32_t">
<span id="k_msgq_put__k_msgqP.voidP.int32_t"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1gab7ac23e554f3557a8ffaebae44902c00"></span>int <code class="descclassname"></code><code class="descname">k_msgq_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, void *<em>data</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a message to a message queue. </p>
<p>This routine sends a message to message queue <em>q</em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Pointer to the message. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to add the message (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message sent. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting or queue purged. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_msgq_getP6k_msgqPv7int32_t">
<span id="k_msgq_get__k_msgqP.voidP.int32_t"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1ga49bebae0f068b05ef421a4b693f8a566"></span>int <code class="descclassname"></code><code class="descname">k_msgq_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em>, void *<em>data</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Receive a message from a message queue. </p>
<p>This routine receives a message from message queue <em>q</em> in a &#8220;first in,
first out&#8221; manner.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs, but <em>timeout</em> must be set to K_NO_WAIT.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of area to hold the received message. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to receive the message (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message received. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212k_msgq_purgeP6k_msgq">
<span id="k_msgq_purge__k_msgqP"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1ga128de935d95fdb686f1df5823c890c9e"></span>void <code class="descclassname"></code><code class="descname">k_msgq_purge</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Purge a message queue. </p>
<p>This routine discards all unreceived messages in a message queue&#8217;s ring buffer. Any threads that are blocked waiting to send a message to the message queue are unblocked and see an -ENOMSG error code.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_msgq_num_free_getP6k_msgq">
<span id="k_msgq_num_free_get__k_msgqP"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1gae53f896bb9734f076b606d3964ffe8c4"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">k_msgq_num_free_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the amount of free space in a message queue. </p>
<p>This routine returns the number of unused entries in a message queue&#8217;s ring buffer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of unused ring buffer entries. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_msgq_num_used_getP6k_msgq">
<span id="k_msgq_num_used_get__k_msgqP"></span><span class="target" id="Zephyrd1/d90/group__msgq__apis_1ga3a397bd7978e208f9744d9d34e620adf"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">k_msgq_num_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>q</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the number of messages in a message queue. </p>
<p>This routine returns the number of messages in a message queue&#8217;s ring buffer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of messages. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q</span></code>: Address of the message queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MSGQ_DEFINE">
<span class="target" id="Zephyrd1/d90/group__msgq__apis_1ga464648d58dec62b40c7855e8dac750ec"></span><code class="descname">K_MSGQ_DEFINE</code><span class="sig-paren">(</span>q_name, q_msg_size, q_max_msgs, q_align<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a message queue. </p>
<p>The message queue&#8217;s ring buffer contains space for <em>q_max_msgs</em> messages, each of which is <em>q_msg_size</em> bytes long. The buffer is aligned to a <em>q_align</em> -byte boundary, which must be a power of 2. To ensure that each message is similarly aligned to this boundary, <em>q_msg_size</em> must also be a multiple of <em>q_align</em>.</p>
<p>The message queue can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_msgq</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">q_name</span></code>: Name of the message queue. </li>
<li><code class="docutils literal"><span class="pre">q_msg_size</span></code>: Message size (in bytes). </li>
<li><code class="docutils literal"><span class="pre">q_max_msgs</span></code>: Maximum number of messages that can be queued. </li>
<li><code class="docutils literal"><span class="pre">q_align</span></code>: Alignment of the message queue&#8217;s ring buffer. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="mailboxes">
<h2><a class="toc-backref" href="#contents">Mailboxes</a></h2>
<p>Mailboxes provide an enhanced message queuing mechanism
for variable-size messages.
(See <a class="reference internal" href="../kernel/data_passing/mailboxes.html#mailboxes-v2"><span class="std std-ref">Mailboxes</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_mbox_initP6k_mbox">
<span id="k_mbox_init__k_mboxP"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1ga686f20c199a9e971822d8279d175d8c2"></span>void <code class="descclassname"></code><code class="descname">k_mbox_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a mailbox. </p>
<p>This routine initializes a mailbox object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_mbox_putP6k_mboxP10k_mbox_msg7int32_t">
<span id="k_mbox_put__k_mboxP.k_mbox_msgP.int32_t"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1ga6548993cd04c653b32e2b0ef65612ab5"></span>int <code class="descclassname"></code><code class="descname">k_mbox_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>tx_msg</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a mailbox message in a synchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> and waits for a receiver to both receive and process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">tx_msg</span></code>: Address of the transmit message descriptor. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period for the message to be received (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER. Once the message has been received, this routine waits as long as necessary for the message to be completely processed.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message sent. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_mbox_async_putP6k_mboxP10k_mbox_msgP5k_sem">
<span id="k_mbox_async_put__k_mboxP.k_mbox_msgP.k_semP"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1gadd60f7b760371c0a141a1e4da253a0f0"></span>void <code class="descclassname"></code><code class="descname">k_mbox_async_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>tx_msg</em>, <em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a mailbox message in an asynchronous manner. </p>
<p>This routine sends a message to <em>mbox</em> without waiting for a receiver to process it. The message data may be in a buffer, in a memory pool block, or non-existent (i.e. an empty message). Optionally, the semaphore <em>sem</em> will be given when the message has been both received and completely processed by the receiver.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">tx_msg</span></code>: Address of the transmit message descriptor. </li>
<li><code class="docutils literal"><span class="pre">sem</span></code>: Address of a semaphore, or NULL if none is needed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_mbox_getP6k_mboxP10k_mbox_msgPv7int32_t">
<span id="k_mbox_get__k_mboxP.k_mbox_msgP.voidP.int32_t"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1gadb8c0b04b9c87aef18ab1e81a75b35c5"></span>int <code class="descclassname"></code><code class="descname">k_mbox_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, void *<em>buffer</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Receive a mailbox message. </p>
<p>This routine receives a message from <em>mbox</em>, then optionally retrieves its data and disposes of the message.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Address of the mailbox. </li>
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of the receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the buffer to receive data, or NULL to defer data retrieval and message disposal until later. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period for a message to be received (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Message received. </li>
<li><code class="docutils literal"><span class="pre">-ENOMSG</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_mbox_data_getP10k_mbox_msgPv">
<span id="k_mbox_data_get__k_mbox_msgP.voidP"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1ga3d19e648e67f109609259543c9a01d6e"></span>void <code class="descclassname"></code><code class="descname">k_mbox_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, void *<em>buffer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve mailbox message data into a buffer. </p>
<p>This routine completes the processing of a received message by retrieving its data into a buffer, then disposing of the message.</p>
<p>Alternatively, this routine can be used to dispose of a received message without retrieving its data.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of the receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the buffer to receive data, or NULL to discard the data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221k_mbox_data_block_getP10k_mbox_msgP10k_mem_poolP11k_mem_block7int32_t">
<span id="k_mbox_data_block_get__k_mbox_msgP.k_mem_poolP.k_mem_blockP.int32_t"></span><span class="target" id="Zephyrd7/df7/group__mailbox__apis_1ga7548d024c05fb823d973ed4cfde507d2"></span>int <code class="descclassname"></code><code class="descname">k_mbox_data_block_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox_msg *<em>rx_msg</em>, <em class="property">struct</em> k_mem_pool *<em>pool</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve mailbox message data into a memory pool block. </p>
<p>This routine completes the processing of a received message by retrieving its data into a memory pool block, then disposing of the message. The memory pool block that results from successful retrieval must be returned to the pool once the data has been processed, even in cases where zero bytes of data are retrieved.</p>
<p>Alternatively, this routine can be used to dispose of a received message without retrieving its data. In this case there is no need to return a memory pool block to the pool.</p>
<p>This routine allocates a new memory pool block for the data only if the data is not already in one. If a new block cannot be allocated, the routine returns a failure code and the received message is left unchanged. This permits the caller to reattempt data retrieval at a later time or to dispose of the received message without retrieving its data.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">rx_msg</span></code>: Address of a receive message descriptor. </li>
<li><code class="docutils literal"><span class="pre">pool</span></code>: Address of memory pool, or NULL to discard data. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Address of the area to hold memory pool block info. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for a memory pool block (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data retrieved. </li>
<li><code class="docutils literal"><span class="pre">-ENOMEM</span></code>: Returned without waiting. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_MBOX_DEFINE">
<span class="target" id="Zephyrd7/df7/group__mailbox__apis_1gab55cba898db47113a06641c01f3e3714"></span><code class="descname">K_MBOX_DEFINE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a mailbox. </p>
<p>The mailbox is to be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_mbox</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the mailbox. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="pipes">
<h2><a class="toc-backref" href="#contents">Pipes</a></h2>
<p>Pipes provide a traditional anonymous pipe mechanism for sending
variable-size chunks of data, in whole or in part.
(See <a class="reference internal" href="../kernel/data_passing/pipes.html#pipes-v2"><span class="std std-ref">Pipes</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_pipe_initP6k_pipePh6size_t">
<span id="k_pipe_init__k_pipeP.unsigned-cP.s"></span><span class="target" id="Zephyrda/d0d/group__pipe__apis_1gae9e807fb63bb7186b87015664f2c762d"></span>void <code class="descclassname"></code><code class="descname">k_pipe_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, unsigned char *<em>buffer</em>, size_t <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a pipe. </p>
<p>This routine initializes a pipe object, prior to its first use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Address of the pipe&#8217;s ring buffer, or NULL if no ring buffer is used. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Size of the pipe&#8217;s ring buffer (in bytes), or zero if no ring buffer is used.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_pipe_putP6k_pipePv6size_tP6size_t6size_t7int32_t">
<span id="k_pipe_put__k_pipeP.voidP.s.sP.s.int32_t"></span><span class="target" id="Zephyrda/d0d/group__pipe__apis_1ga8f8391333e2c5e9853f127acb6b8928e"></span>int <code class="descclassname"></code><code class="descname">k_pipe_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, void *<em>data</em>, size_t <em>bytes_to_write</em>, size_t *<em>bytes_written</em>, size_t <em>min_xfer</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write data to a pipe. </p>
<p>This routine writes up to <em>bytes_to_write</em> bytes of data to <em>pipe</em>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of data to write. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_write</span></code>: Size of data (in bytes). </li>
<li><code class="docutils literal"><span class="pre">bytes_written</span></code>: Address of area to hold the number of bytes written. </li>
<li><code class="docutils literal"><span class="pre">min_xfer</span></code>: Minimum number of bytes to write. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for the data to be written (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: At least <em>min_xfer</em> bytes of data were written. </li>
<li><code class="docutils literal"><span class="pre">-EIO</span></code>: Returned without waiting; zero data bytes were written. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out; between zero and <em>min_xfer</em> minus one data bytes were written. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210k_pipe_getP6k_pipePv6size_tP6size_t6size_t7int32_t">
<span id="k_pipe_get__k_pipeP.voidP.s.sP.s.int32_t"></span><span class="target" id="Zephyrda/d0d/group__pipe__apis_1ga38d8fceb3181680f91f70141c9a0c6f5"></span>int <code class="descclassname"></code><code class="descname">k_pipe_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, void *<em>data</em>, size_t <em>bytes_to_read</em>, size_t *<em>bytes_read</em>, size_t <em>min_xfer</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read data from a pipe. </p>
<p>This routine reads up to <em>bytes_to_read</em> bytes of data from <em>pipe</em>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address to place the data read from pipe. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_read</span></code>: Maximum number of data bytes to read. </li>
<li><code class="docutils literal"><span class="pre">bytes_read</span></code>: Address of area to hold the number of bytes read. </li>
<li><code class="docutils literal"><span class="pre">min_xfer</span></code>: Minimum number of data bytes to read. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Waiting period to wait for the data to be read (in milliseconds), or one of the special values K_NO_WAIT and K_FOREVER.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: At least <em>min_xfer</em> bytes of data were read. </li>
<li><code class="docutils literal"><span class="pre">-EIO</span></code>: Returned without waiting; zero data bytes were read. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Waiting period timed out; between zero and <em>min_xfer</em> minus one data bytes were read. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216k_pipe_block_putP6k_pipeP11k_mem_block6size_tP5k_sem">
<span id="k_pipe_block_put__k_pipeP.k_mem_blockP.s.k_semP"></span><span class="target" id="Zephyrda/d0d/group__pipe__apis_1ga48b800f700f0384a8b2b0260bc3b14da"></span>void <code class="descclassname"></code><code class="descname">k_pipe_block_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>pipe</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, size_t <em>size</em>, <em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write memory block to a pipe. </p>
<p>This routine writes the data contained in a memory block to <em>pipe</em>. Once all of the data in the block has been written to the pipe, it will free the memory block <em>block</em> and give the semaphore <em>sem</em> (if specified).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pipe</span></code>: Address of the pipe. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Memory block containing data to send </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Number of data bytes in memory block to send </li>
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore to signal upon completion (else NULL)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.K_PIPE_DEFINE">
<span class="target" id="Zephyrda/d0d/group__pipe__apis_1ga67d521797ffc37aeeadf3f4dc5339484"></span><code class="descname">K_PIPE_DEFINE</code><span class="sig-paren">(</span>name, pipe_buffer_size, pipe_align<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a pipe. </p>
<p>The pipe can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">k_pipe</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the pipe. </li>
<li><code class="docutils literal"><span class="pre">pipe_buffer_size</span></code>: Size of the pipe&#8217;s ring buffer (in bytes), or zero if no ring buffer is used. </li>
<li><code class="docutils literal"><span class="pre">pipe_align</span></code>: Alignment of the pipe&#8217;s ring buffer (power of 2). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="interrupt-service-routines-isrs">
<h2><a class="toc-backref" href="#contents">Interrupt Service Routines (ISRs)</a></h2>
<p>An interrupt service routine is a series of instructions that is
executed asynchronously in response to a hardware or software interrupt.
(See <a class="reference internal" href="../kernel/other/interrupts.html#interrupts-v2"><span class="std std-ref">Interrupts</span></a>.)</p>
<dl class="function">
<dt id="_CPPv211k_is_in_isrv">
<span id="k_is_in_isr__void"></span><span class="target" id="Zephyrda/d00/group__isr__apis_1ga7d3be1c531238fda9822430976f2d6b4"></span>int <code class="descclassname"></code><code class="descname">k_is_in_isr</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Determine if code is running at interrupt level. </p>
<p>This routine allows the caller to customize its actions, depending on whether it is a thread or an ISR.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>0 if invoked by a thread. </dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if invoked by an ISR. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219k_is_preempt_threadv">
<span id="k_is_preempt_thread__void"></span><span class="target" id="Zephyrda/d00/group__isr__apis_1ga91e1cf0dc7fc93a3214cadb74ed86666"></span>int <code class="descclassname"></code><code class="descname">k_is_preempt_thread</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Determine if code is running in a preemptible thread. </p>
<p>This routine allows the caller to customize its actions, depending on whether it can be preempted by another thread. The routine returns a &#8216;true&#8217; value if all of the following conditions are met:</p>
<p><ul class="simple">
<li>The code is running in a thread, not at ISR.</li>
<li>The thread&#8217;s priority is in the preemptible range.</li>
<li>The thread has not locked the scheduler.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>0 if invoked by an ISR or by a cooperative thread. </dd>
<dt><strong>Return</strong></dt>
<dd>Non-zero if invoked by a preemptible thread. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.IRQ_CONNECT">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga131739d1faf501a15590053817aba984"></span><code class="descname">IRQ_CONNECT</code><span class="sig-paren">(</span>irq_p, priority_p, isr_p, isr_param_p, flags_p<span class="sig-paren">)</span></dt>
<dd><p>Initialize an interrupt handler. </p>
<p>This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled before the interrupt handler begins servicing interrupts.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Although this routine is invoked at run-time, all of its arguments must be computable by the compiler at build time.</dd>
<dt><strong>Return</strong></dt>
<dd>Interrupt vector assigned to this interrupt. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq_p</span></code>: IRQ line number. </li>
<li><code class="docutils literal"><span class="pre">priority_p</span></code>: Interrupt priority. </li>
<li><code class="docutils literal"><span class="pre">isr_p</span></code>: Address of interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">isr_param_p</span></code>: Parameter passed to interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">flags_p</span></code>: Architecture-specific IRQ configuration flags..</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_lock">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga19fdde73c3b02fcca6cf1d1e67631228"></span><code class="descname">irq_lock</code></dt>
<dd><p>Lock interrupts. </p>
<p>This routine disables all interrupts on the CPU. It returns an unsigned integer &#8220;lock-out key&#8221;, which is an architecture-dependent indicator of whether interrupts were locked prior to the call. The lock-out key must be passed to irq_unlock() to re-enable interrupts.</p>
<p>This routine can be called recursively, as long as the caller keeps track of each lock-out key that is generated. Interrupts are re-enabled by passing each of the keys to irq_unlock() in the reverse order they were acquired. (That is, each call to irq_lock() must be balanced by a corresponding call to irq_unlock().)</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This routine can be called by ISRs or by threads. If it is called by a thread, the interrupt lock is thread-specific; this means that interrupts remain disabled only while the thread is running. If the thread performs an operation that allows another thread to run (for example, giving a semaphore or sleeping for N milliseconds), the interrupt lock no longer applies and interrupts may be re-enabled while other processing occurs. When the thread once again becomes the current thread, the kernel re-establishes its interrupt lock; this ensures the thread won&#8217;t be interrupted until it has explicitly released the interrupt lock it established.</dd>
<dt><strong>Warning</strong></dt>
<dd>The lock-out key should never be used to manually re-enable interrupts or to inspect or manipulate the contents of the CPU&#8217;s interrupt bits.</dd>
<dt><strong>Return</strong></dt>
<dd>Lock-out key. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_unlock">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga646045943b3b2a130738bcc48867bf57"></span><code class="descname">irq_unlock</code><span class="sig-paren">(</span>key<span class="sig-paren">)</span></dt>
<dd><p>Unlock interrupts. </p>
<p>This routine reverses the effect of a previous call to irq_lock() using the associated lock-out key. The caller must call the routine once for each time it called irq_lock(), supplying the keys in the reverse order they were acquired, before interrupts are enabled.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can be called by ISRs.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">key</span></code>: Lock-out key generated by irq_lock().</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_enable">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga7ea700ee31e4ff036c997a554dbedfeb"></span><code class="descname">irq_enable</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span></dt>
<dd><p>Enable an IRQ. </p>
<p>This routine enables interrupts from source <em>irq</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_disable">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga82c3a15d812f58e0f6525f358d031e6d"></span><code class="descname">irq_disable</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span></dt>
<dd><p>Disable an IRQ. </p>
<p>This routine disables interrupts from source <em>irq</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.irq_is_enabled">
<span class="target" id="Zephyrda/d00/group__isr__apis_1ga71fef3867ba9818cf0a5baf8410a6354"></span><code class="descname">irq_is_enabled</code><span class="sig-paren">(</span>irq<span class="sig-paren">)</span></dt>
<dd><p>Get IRQ enable state. </p>
<p>This routine indicates if interrupts from source <em>irq</em> are enabled.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>interrupt enable state, true or false </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">irq</span></code>: IRQ line.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="atomic-services">
<h2><a class="toc-backref" href="#contents">Atomic Services</a></h2>
<p>The atomic services enable multiple threads and ISRs to read and modify
32-bit variables in an uninterruptible manner.
(See <a class="reference internal" href="../kernel/other/atomic.html#atomic-v2"><span class="std std-ref">Atomic Services</span></a>.)</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">All atomic services APIs can be used by both threads and ISRs.</p>
</div>
<dl class="function">
<dt id="_CPPv210atomic_casP8atomic_t12atomic_val_t12atomic_val_t">
<span id="atomic_cas__atomic_tP.atomic_val_t.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga1f735954844cb1a70ff23ba628899f3e"></span>int <code class="descclassname"></code><code class="descname">atomic_cas</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>old_value</em>, atomic_val_t <em>new_value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic compare-and-set. </p>
<p>This routine performs an atomic compare-and-set on <em>target</em>. If the current value of <em>target</em> equals <em>old_value</em>, <em>target</em> is set to <em>new_value</em>. If the current value of <em>target</em> does not equal <em>old_value</em>, <em>target</em> is left unchanged.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if <em>new_value</em> is written, 0 otherwise. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">old_value</span></code>: Original value to compare against. </li>
<li><code class="docutils literal"><span class="pre">new_value</span></code>: New value to store. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_addP8atomic_t12atomic_val_t">
<span id="atomic_add__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga518c07595daaca29a9e53071ed59c9c0"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_add</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic addition. </p>
<p>This routine performs an atomic addition on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to add.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_subP8atomic_t12atomic_val_t">
<span id="atomic_sub__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga84ab58fd0a6dbbf1bf675722b5900bd7"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_sub</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic subtraction. </p>
<p>This routine performs an atomic subtraction on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to subtract.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_incP8atomic_t">
<span id="atomic_inc__atomic_tP"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1gaae47a9cbe5a6534967b417f602b37ac2"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_inc</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic increment. </p>
<p>This routine performs an atomic increment by 1 on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_decP8atomic_t">
<span id="atomic_dec__atomic_tP"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1gac260f0efbd970717eae4ac3bb493a0c4"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_dec</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic decrement. </p>
<p>This routine performs an atomic decrement by 1 on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_getPK8atomic_t">
<span id="atomic_get__atomic_tCP"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga33bb426a17535bd1022895a7e44b32fa"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_get</code><span class="sig-paren">(</span><em class="property">const</em> atomic_t *<em>target</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic get. </p>
<p>This routine performs an atomic read on <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_setP8atomic_t12atomic_val_t">
<span id="atomic_set__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga5f0555245d8932c2e7f7e94575e1a095"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_set</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic get-and-set. </p>
<p>This routine atomically sets <em>target</em> to <em>value</em> and returns the previous value of <em>target</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to write to <em>target</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212atomic_clearP8atomic_t">
<span id="atomic_clear__atomic_tP"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga879b5f540c25fd09f1b84563e3dc8a91"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_clear</code><span class="sig-paren">(</span>atomic_t *<em>target</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic clear. </p>
<p>This routine atomically sets <em>target</em> to zero and returns its previous value. (Hence, it is equivalent to atomic_set(target, 0).)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29atomic_orP8atomic_t12atomic_val_t">
<span id="atomic_or__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga1564a44a260e7d0d02e30ae045a99764"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_or</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic bitwise inclusive OR. </p>
<p>This routine atomically sets <em>target</em> to the bitwise inclusive OR of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to OR.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_xorP8atomic_t12atomic_val_t">
<span id="atomic_xor__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga18592bcf38d667fb9b428f81ea691bd4"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_xor</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic bitwise exclusive OR (XOR). </p>
<p>This routine atomically sets <em>target</em> to the bitwise exclusive OR (XOR) of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to XOR</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210atomic_andP8atomic_t12atomic_val_t">
<span id="atomic_and__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga4bc1f6a6f5d98eef742b4541d235811d"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_and</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic bitwise AND. </p>
<p>This routine atomically sets <em>target</em> to the bitwise AND of <em>target</em> and <em>value</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to AND.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211atomic_nandP8atomic_t12atomic_val_t">
<span id="atomic_nand__atomic_tP.atomic_val_t"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga3e954286e40de73e45598a00a0a2b864"></span>atomic_val_t <code class="descclassname"></code><code class="descname">atomic_nand</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, atomic_val_t <em>value</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomic bitwise NAND. </p>
<p>This routine atomically sets <em>target</em> to the bitwise NAND of <em>target</em> and <em>value</em>. (This operation is equivalent to target = ~(target &amp; value).)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Previous value of <em>target</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Value to NAND.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215atomic_test_bitPK8atomic_ti">
<span id="atomic_test_bit__atomic_tCP.i"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga08971aaa4161b6271fb258c816b831f6"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">atomic_test_bit</code><span class="sig-paren">(</span><em class="property">const</em> atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically test a bit. </p>
<p>This routine tests whether bit number <em>bit</em> of <em>target</em> is set or not. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn&#8217;t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225atomic_test_and_clear_bitP8atomic_ti">
<span id="atomic_test_and_clear_bit__atomic_tP.i"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1gad1f355a1833ffb2caba13115975c2cad"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">atomic_test_and_clear_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically test and clear a bit. </p>
<p>Atomically clear bit number <em>bit</em> of <em>target</em> and return its old value. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn&#8217;t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223atomic_test_and_set_bitP8atomic_ti">
<span id="atomic_test_and_set_bit__atomic_tP.i"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga5a26c1dc6c768061a16ff84c3f45e730"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">atomic_test_and_set_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically set a bit. </p>
<p>Atomically set bit number <em>bit</em> of <em>target</em> and return its old value. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the bit was set, 0 if it wasn&#8217;t. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216atomic_clear_bitP8atomic_ti">
<span id="atomic_clear_bit__atomic_tP.i"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga1c1693d524c49d11fd32b323a39d718e"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">atomic_clear_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically clear a bit. </p>
<p>Atomically clear bit number <em>bit</em> of <em>target</em>. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214atomic_set_bitP8atomic_ti">
<span id="atomic_set_bit__atomic_tP.i"></span><span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga17a3961ba7610ad6e595e602f70344a0"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">atomic_set_bit</code><span class="sig-paren">(</span>atomic_t *<em>target</em>, int <em>bit</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically set a bit. </p>
<p>Atomically set bit number <em>bit</em> of <em>target</em>. The target may be a single atomic variable or an array of them.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">target</span></code>: Address of atomic variable or array. </li>
<li><code class="docutils literal"><span class="pre">bit</span></code>: Bit number (starting from 0).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ATOMIC_INIT">
<span class="target" id="Zephyrdc/d38/group__atomic__apis_1gaadfbba86627ee7eeb07e04f712550f73"></span><code class="descname">ATOMIC_INIT</code><span class="sig-paren">(</span>i<span class="sig-paren">)</span></dt>
<dd><p>Initialize an atomic variable. </p>
<p>This macro can be used to initialize an atomic variable. For example, <div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">atomic_t</span> <span class="n">my_var</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">75</span><span class="p">);</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">i</span></code>: Value to assign to atomic variable. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.ATOMIC_DEFINE">
<span class="target" id="Zephyrdc/d38/group__atomic__apis_1ga249c575db9764486197709b327f7370e"></span><code class="descname">ATOMIC_DEFINE</code><span class="sig-paren">(</span>name, num_bits<span class="sig-paren">)</span></dt>
<dd><p>Define an array of atomic variables. </p>
<p>This macro defines an array of atomic variables containing at least <em>num_bits</em> bits.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If used from file scope, the bits of the array are initialized to zero; if used from within a function, the bits are left uninitialized.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of array of atomic variables. </li>
<li><code class="docutils literal"><span class="pre">num_bits</span></code>: Number of bits needed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="floating-point-services">
<h2><a class="toc-backref" href="#contents">Floating Point Services</a></h2>
<p>The floating point services enable threads to use a board&#8217;s floating point
registers.
(See <a class="reference internal" href="../kernel/other/float.html#float-v2"><span class="std std-ref">Floating Point Services</span></a>.)</p>
<dl class="function">
<dt id="_CPPv214k_float_enable7k_tid_tj">
<span id="k_float_enable__k_tid_t.unsigned-i"></span><span class="target" id="Zephyrd6/dd7/group__float__apis_1gaa13fb58f5f8eaba79aa3fb7d59514a49"></span>void <code class="descclassname"></code><code class="descname">k_float_enable</code><span class="sig-paren">(</span>k_tid_t <em>thread</em>, unsigned int <em>options</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable preservation of floating point context information. </p>
<p>This routine informs the kernel that the specified thread (which may be the current thread) will be using the floating point registers. The <em>options</em> parameter indicates which floating point register sets will be used by the specified thread:</p>
<p>a) K_FP_REGS indicates x87 FPU and MMX registers only b) K_SSE_REGS indicates SSE registers (and also x87 FPU and MMX registers)</p>
<p>Invoking this routine initializes the thread&#8217;s floating point context info to that of an FPU that has been reset. The next time the thread is scheduled by _Swap() it will either inherit an FPU that is guaranteed to be in a &#8220;sane&#8221; state (if the most recent user of the FPU was cooperatively swapped out) or the thread&#8217;s own floating point context will be loaded (if the most recent user of the FPU was pre-empted, or if this thread is the first user of the FPU). Thereafter, the kernel will protect the thread&#8217;s FP context so that it is not altered during a preemptive context switch.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This routine should only be used to enable floating point support for a thread that does not currently have such support enabled already.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Registers to be preserved (K_FP_REGS or K_SSE_REGS).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215k_float_disable7k_tid_t">
<span id="k_float_disable__k_tid_t"></span><span class="target" id="Zephyrd6/dd7/group__float__apis_1ga74bfced0c73c26293d3b67083892406e"></span>void <code class="descclassname"></code><code class="descname">k_float_disable</code><span class="sig-paren">(</span>k_tid_t <em>thread</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Disable preservation of floating point context information. </p>
<p>This routine informs the kernel that the specified thread (which may be the current thread) will no longer be using the floating point registers.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This routine should only be used to disable floating point support for a thread that currently has such support enabled.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">thread</span></code>: ID of thread.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ring-buffers">
<h2><a class="toc-backref" href="#contents">Ring Buffers</a></h2>
<p>Ring buffers enable simple first in, first out (FIFO) queuing
of variable-size data items.
(See <a class="reference internal" href="../kernel/other/ring_buffers.html#ring-buffers-v2"><span class="std std-ref">Ring Buffers</span></a>.)</p>
<dl class="function">
<dt id="_CPPv217sys_ring_buf_initP8ring_buf8uint32_tP8uint32_t">
<span id="sys_ring_buf_init__ring_bufP.uint32_t.uint32_tP"></span><span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1ga60e30022e9cac80a124eb3b8418bca41"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sys_ring_buf_init</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, uint32_t <em>size</em>, uint32_t *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a ring buffer. </p>
<p>This routine initializes a ring buffer, prior to its first use. It is only used for ring buffers not defined using SYS_RING_BUF_DECLARE_POW2 or SYS_RING_BUF_DECLARE_SIZE.</p>
<p>Setting <em>size</em> to a power of 2 establishes a high performance ring buffer that doesn&#8217;t require the use of modulo arithmetic operations to maintain itself.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">size</span></code>: Ring buffer size (in 32-bit words). </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Ring buffer data area (typically uint32_t data[size]). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221sys_ring_buf_is_emptyP8ring_buf">
<span id="sys_ring_buf_is_empty__ring_bufP"></span><span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1ga1322214c33835c164f6c83088ccb5426"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sys_ring_buf_is_empty</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Determine if a ring buffer is empty. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 if the ring buffer is empty, or 0 if not. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222sys_ring_buf_space_getP8ring_buf">
<span id="sys_ring_buf_space_get__ring_bufP"></span><span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1gac86de55625f8834a94a3b9458ada225e"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">sys_ring_buf_space_get</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Determine free space in a ring buffer. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Ring buffer free space (in 32-bit words). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216sys_ring_buf_putP8ring_buf8uint16_t7uint8_tP8uint32_t7uint8_t">
<span id="sys_ring_buf_put__ring_bufP.uint16_t.uint8_t.uint32_tP.uint8_t"></span><span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1gadd27aa91aef9b8460538805db2d2438d"></span>int <code class="descclassname"></code><code class="descname">sys_ring_buf_put</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, uint16_t <em>type</em>, uint8_t <em>value</em>, uint32_t *<em>data</em>, uint8_t <em>size32</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write a data item to a ring buffer. </p>
<p>This routine writes a data item to ring buffer <em>buf</em>. The data item is an array of 32-bit words (from zero to 1020 bytes in length), coupled with a 16-bit type identifier and an 8-bit integer value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Use cases involving multiple writers to the ring buffer must prevent concurrent write operations, either by preventing all writers from being preempted or by using a mutex to govern writes to the ring buffer.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: Data item&#8217;s type identifier (application specific). </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Data item&#8217;s integer value (application specific). </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Address of data item. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Data item size (number of 32-bit words).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data item was written. </li>
<li><code class="docutils literal"><span class="pre">-EMSGSIZE</span></code>: Ring buffer has insufficient free space. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216sys_ring_buf_getP8ring_bufP8uint16_tP7uint8_tP8uint32_tP7uint8_t">
<span id="sys_ring_buf_get__ring_bufP.uint16_tP.uint8_tP.uint32_tP.uint8_tP"></span><span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1ga916aa96358193c1331419a7f9f552192"></span>int <code class="descclassname"></code><code class="descname">sys_ring_buf_get</code><span class="sig-paren">(</span><em class="property">struct</em> ring_buf *<em>buf</em>, uint16_t *<em>type</em>, uint8_t *<em>value</em>, uint32_t *<em>data</em>, uint8_t *<em>size32</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read a data item from a ring buffer. </p>
<p>This routine reads a data item from ring buffer <em>buf</em>. The data item is an array of 32-bit words (up to 1020 bytes in length), coupled with a 16-bit type identifier and an 8-bit integer value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Use cases involving multiple reads of the ring buffer must prevent concurrent read operations, either by preventing all readers from being preempted or by using a mutex to govern reads to the ring buffer.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">buf</span></code>: Address of ring buffer. </li>
<li><code class="docutils literal"><span class="pre">type</span></code>: Area to store the data item&#8217;s type identifier. </li>
<li><code class="docutils literal"><span class="pre">value</span></code>: Area to store the data item&#8217;s integer value. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Area to store the data item. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Size of the data item storage area (number of 32-bit chunks).</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">0</span></code>: Data item was fetched; <em>size32</em> now contains the number of 32-bit words read into data area <em>data</em>. </li>
<li><code class="docutils literal"><span class="pre">-EAGAIN</span></code>: Ring buffer is empty. </li>
<li><code class="docutils literal"><span class="pre">-EMSGSIZE</span></code>: Data area <em>data</em> is too small; <em>size32</em> now contains the number of 32-bit words needed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_RING_BUF_DECLARE_POW2">
<span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1ga3c62d9daa70ece8f00c9e7c607ac5f29"></span><code class="descname">SYS_RING_BUF_DECLARE_POW2</code><span class="sig-paren">(</span>name, pow<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a high performance ring buffer. </p>
<p>This macro establishes a ring buffer whose size must be a power of 2; that is, the ring buffer contains 2^pow 32-bit words, where <em>pow</em> is the specified ring buffer size exponent. A high performance ring buffer doesn&#8217;t require the use of modulo arithmetic operations to maintain itself.</p>
<p>The ring buffer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">ring_buf</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the ring buffer. </li>
<li><code class="docutils literal"><span class="pre">pow</span></code>: Ring buffer size exponent. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.SYS_RING_BUF_DECLARE_SIZE">
<span class="target" id="Zephyrd4/dc5/group__ring__buffer__apis_1ga4f82802fe81fd71ed801c5e4eaab926a"></span><code class="descname">SYS_RING_BUF_DECLARE_SIZE</code><span class="sig-paren">(</span>name, size32<span class="sig-paren">)</span></dt>
<dd><p>Statically define and initialize a standard ring buffer. </p>
<p>This macro establishes a ring buffer of an arbitrary size. A standard ring buffer uses modulo arithmetic operations to maintain itself.</p>
<p>The ring buffer can be accessed outside the module where it is defined using:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">struct</span> <span class="n">ring_buf</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span> 
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the ring buffer. </li>
<li><code class="docutils literal"><span class="pre">size32</span></code>: Size of ring buffer (in 32-bit words). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="legacy-apis">
<h2><a class="toc-backref" href="#contents">Legacy APIs</a></h2>
<p>These APIs will be deprecated in an upcoming release so we recommend you avoid
using them in your applications.</p>
<dl class="function">
<dt id="_CPPv219sys_thread_self_getv">
<span id="sys_thread_self_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8e410682615cc562a4696370cd901c12"></span><em class="property">static</em> k_tid_t <code class="descclassname"></code><code class="descname">sys_thread_self_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return the ID of the currently executing thread. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine returns a pointer to the thread control block of the currently executing thread. It is cast to a nano_thread_id_t for public use.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The ID of the currently executing thread. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220sys_thread_busy_wait8uint32_t">
<span id="sys_thread_busy_wait__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3a40aa83f173965aee94cc7e0da06b9d"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sys_thread_busy_wait</code><span class="sig-paren">(</span>uint32_t <em>usec_to_wait</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Cause the currently executing thread to busy wait. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine causes the current task or fiber to execute a &#8220;do nothing&#8221; loop for a specified period of time.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>This routine utilizes the system clock, so it must not be invoked until the system clock is fully operational or while interrupts are locked.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">usec_to_wait</span></code>: Number of microseconds to busy wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv230sys_execution_context_type_getv">
<span id="sys_execution_context_type_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7302318cbc7bd7c1eea679169f7c9de9"></span>int <code class="descclassname"></code><code class="descname">sys_execution_context_type_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return the type of the current execution context. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine returns the type of execution context currently executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The type of the current execution context. </dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">NANO_CTX_ISR</span></code>: (0): executing an interrupt service routine. </li>
<li><code class="docutils literal"><span class="pre">NANO_CTX_FIBER</span></code>: (1): current thread is a fiber. </li>
<li><code class="docutils literal"><span class="pre">NANO_CTX_TASK</span></code>: (2): current thread is a task. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211fiber_startPcj18nano_fiber_entry_tiijj">
<span id="fiber_start__cP.unsigned.nano_fiber_entry_t.i.i.unsigned.unsigned"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga68b4dbd77eb89e5b50eb4cda17e3b8d7"></span><em class="property">static</em> k_tid_t <code class="descclassname"></code><code class="descname">fiber_start</code><span class="sig-paren">(</span>char *<em>stack</em>, unsigned <em>stack_size</em>, nano_fiber_entry_t <em>entry</em>, int <em>arg1</em>, int <em>arg2</em>, unsigned <em>prio</em>, unsigned <em>options</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize and start a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine initializes and starts a fiber. It can be called from either a fiber or a task. When this routine is called from a task, the newly created fiber will start executing immediately.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>nanokernel thread identifier </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to the stack space. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Fiber entry. </li>
<li><code class="docutils literal"><span class="pre">arg1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">arg2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: The fiber&#8217;s priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Not used currently.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219fiber_delayed_startPcj18nano_fiber_entry_tiijj7int32_t">
<span id="fiber_delayed_start__cP.unsigned-i.nano_fiber_entry_t.i.i.unsigned-i.unsigned-i.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac115b199a1b94b6e85b2a6ddde3779b8"></span><em class="property">static</em> k_tid_t <code class="descclassname"></code><code class="descname">fiber_delayed_start</code><span class="sig-paren">(</span>char *<em>stack</em>, unsigned int <em>stack_size_in_bytes</em>, nano_fiber_entry_t <em>entry_point</em>, int <em>param1</em>, int <em>param2</em>, unsigned int <em>priority</em>, unsigned int <em>options</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a fiber while delaying its execution. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A handle potentially used to cancel the delayed start. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Pointer to the stack space. </li>
<li><code class="docutils literal"><span class="pre">stack_size_in_bytes</span></code>: Stack size in bytes. </li>
<li><code class="docutils literal"><span class="pre">entry_point</span></code>: The fiber&#8217;s entry point. </li>
<li><code class="docutils literal"><span class="pre">param1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">param2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">priority</span></code>: The fiber&#8217;s priority. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Not used currently. </li>
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Timeout duration in ticks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv226fiber_delayed_start_cancel7k_tid_t">
<span id="fiber_delayed_start_cancel__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8dd0f66df6be21ecbc8ba8c388bfdf77"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">fiber_delayed_start_cancel</code><span class="sig-paren">(</span>k_tid_t <em>handle</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Cancel a delayed fiber start. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">handle</span></code>: The handle returned when starting the delayed fiber.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211fiber_yieldv">
<span id="fiber_yield__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa83a2883ce0ac0d1b538c881f6fc4882"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">fiber_yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Yield the current fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Calling this routine results in the current fiber yielding to another fiber of the same or higher priority. If there are no other runnable fibers of the same or higher priority, the routine will return immediately.</p>
<p>This routine can only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211fiber_abortv">
<span id="fiber_abort__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga33003e0df3c036df67b746640bf10db4"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">fiber_abort</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Abort the currently executing fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine aborts the currently executing fiber. An abort can occur because of one of three reasons:<ul class="simple">
<li>The fiber has explicitly aborted itself by calling this routine.</li>
<li>The fiber has implicitly aborted itself by returning from its entry point.</li>
<li>The fiber has encountered a fatal exception.</li>
</ul>
</p>
<p>This routine can only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213_legacy_sleep7int32_t">
<span id="_legacy_sleep__int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaaafe6574ca948973668a692fad4c34d0"></span>void <code class="descclassname"></code><code class="descname">_legacy_sleep</code><span class="sig-paren">(</span>int32_t <em>ticks</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv212fiber_wakeup7k_tid_t">
<span id="fiber_wakeup__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga19c41ce37bb52d36b1827c40eed99188"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">fiber_wakeup</code><span class="sig-paren">(</span>k_tid_t <em>fiber</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Wake the specified fiber from sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine is a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fiber</span></code>: Identifies fiber to wake</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217task_priority_set7k_tid_t8uint32_t">
<span id="task_priority_set__k_tid_t.uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad2d4000947dbb35efb6d3255ee367829"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_priority_set</code><span class="sig-paren">(</span>k_tid_t <em>task</em>, uint32_t <em>prio</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the priority of a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine changes the priority of the specified task.</p>
<p>The call has immediate effect. When the calling task no longer is the highest-priority runnable task, a task switch occurs.</p>
<p>Priority can be assigned in the range 0 to 62, where 0 is the highest priority.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task whose priority is to be set. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: New priority.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214task_entry_set7k_tid_tPFvvE">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga411d8cf16f1b8ae496d7ad883ad1c469"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_entry_set</code><span class="sig-paren">(</span>k_tid_t <em>task</em>, void (*<em>entry</em>)<span class="sig-paren">(</span>void<span class="sig-paren">)</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the entry point of a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine sets the entry point of a task to a given routine. It is needed only when an entry point differs from what is set in the project file. To have any effect, it must be called before task_start(), and it cannot work with members of the EXE group or with any group that starts automatically on application loading.</p>
<p>The routine is executed when the task is started.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task to operate on. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Entry point.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222task_abort_handler_setPFvvE">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gace89e289d1895dcbdb49d4ad27dd9c49"></span>void <code class="descclassname"></code><code class="descname">task_abort_handler_set</code><span class="sig-paren">(</span>void (*<em>handler</em>)<span class="sig-paren">(</span>void<span class="sig-paren">)</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Install an abort handler. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine installs an abort handler for the calling task.</p>
<p>The abort handler runs when the calling task is aborted by a _TaskAbort() or task_group_abort() call.</p>
<p>Each call to task_abort_handler_set() replaces the previously-installed handler.</p>
<p>To remove an abort handler, set the parameter to NULL as below: task_abort_handler_set (NULL)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">handler</span></code>: Abort handler.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221task_offload_to_fiberPFivEPv">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0a6344a3e949cc5a198b9ce31cbf0720"></span>int <code class="descclassname"></code><code class="descname">task_offload_to_fiber</code><span class="sig-paren">(</span>int (*<em>func</em>)<span class="sig-paren">(</span><span class="sig-paren">)</span>void *<em>argp</em>, <span class="sig-paren">)</span><br /></dt>
<dd><p>Process an &#8220;offload&#8221; request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>The routine places the <em>func</em> into the work queue. This allows the task to execute a routine uninterrupted by other tasks.</p>
<p>Note: this routine can be invoked only from a task. For the routine to work, the scheduler must be unlocked.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>result of <em>func</em> call </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">func</span></code>: function to call </li>
<li><code class="docutils literal"><span class="pre">argp</span></code>: function arguments</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211task_id_getv">
<span id="task_id_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga14dc88444a48be0f2bc5d1736d98a3e2"></span><em class="property">static</em> k_tid_t <code class="descclassname"></code><code class="descname">task_id_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Gets task identifier. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>identifier for current task </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217task_priority_getv">
<span id="task_priority_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga86caf0fab45fba5215ac957c765ab26f"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">task_priority_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Gets task priority. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>priority of current task </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210task_abort7k_tid_t">
<span id="task_abort__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3c9751c4aa87427f35b21d75b7db675f"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_abort</code><span class="sig-paren">(</span>k_tid_t <em>task</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Abort a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task to abort</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212task_suspend7k_tid_t">
<span id="task_suspend__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7c9b4385a1bef143dc441f4a62ca57c3"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_suspend</code><span class="sig-paren">(</span>k_tid_t <em>task</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Suspend a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task to suspend</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211task_resume7k_tid_t">
<span id="task_resume__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga4cf6de66a1ee01d415be6da3969b4403"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_resume</code><span class="sig-paren">(</span>k_tid_t <em>task</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Resume a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task to resume</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv210task_start7k_tid_t">
<span id="task_start__k_tid_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga060ae6898303c1c274358fe27bf72f7c"></span>void <code class="descclassname"></code><code class="descname">task_start</code><span class="sig-paren">(</span>k_tid_t <em>task</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">task</span></code>: Task to start</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv228sys_scheduler_time_slice_set7int32_t8uint32_t">
<span id="sys_scheduler_time_slice_set__int32_t.uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga9634ad63cae7d127e3be7bb98aec57ad"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">sys_scheduler_time_slice_set</code><span class="sig-paren">(</span>int32_t <em>ticks</em>, uint32_t <em>priority</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set time-slicing period and scope. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine controls how task time slicing is performed by the task scheduler; it specifes the maximum time slice length (in ticks) and the highest priority task level for which time slicing is performed.</p>
<p>To enable time slicing, a non-zero time slice length must be specified. The task scheduler then ensures that no executing task runs for more than the specified number of ticks before giving other tasks of that priority a chance to execute. (However, any task whose priority is higher than the specified task priority level is exempted, and may execute as long as desired without being pre-empted due to time slicing.)</p>
<p>Time slicing limits only the maximum amount of time a task may continuously execute. Once the scheduler selects a task for execution, there is no minimum guaranteed time the task will execute before tasks of greater or equal priority are scheduled.</p>
<p>When the currently-executing task is the only one of that priority eligible for execution, this routine has no effect; the task is immediately rescheduled after the slice period expires.</p>
<p>To disable timeslicing, call the API with both parameters set to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ticks</span></code>: Maximum time slice length in ticks </li>
<li><code class="docutils literal"><span class="pre">priority</span></code>: Highest priority task level for which time slicing is performed</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218_k_thread_group_op8uint32_tPFvP3tcsE">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac5530da808adce82d68fa4f89ab4441b"></span>void <code class="descclassname"></code><code class="descname">_k_thread_group_op</code><span class="sig-paren">(</span>uint32_t <em>groups</em>, void (*<em>func</em>)<span class="sig-paren">(</span><em class="property">struct</em> tcs *<span class="sig-paren">)</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv219task_group_mask_getv">
<span id="task_group_mask_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga17d5cf322bd27dc6e6bccc2fd3af115d"></span><em class="property">static</em> uint32_t <code class="descclassname"></code><code class="descname">task_group_mask_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Get task groups for task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>task groups associated with current task </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215task_group_join8uint32_t">
<span id="task_group_join__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gab59f54e638701ca5afbcd9af046a911f"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_join</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add task to task group(s) </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task Groups</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216task_group_leave8uint32_t">
<span id="task_group_leave__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaf1d2e44e44193f91200bea6529add3cb"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_leave</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Remove task from task group(s) </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task Groups</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216task_group_start8uint32_t">
<span id="task_group_start__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3d07208db3c193d38c4b4c177aeeb7a4"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_start</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start one or more task groups. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task groups to start</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_group_suspend8uint32_t">
<span id="task_group_suspend__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga71e448048aa7ea8ae303bd7f1962bb68"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_suspend</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Suspend one or more task groups. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task groups to suspend</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217task_group_resume8uint32_t">
<span id="task_group_resume__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga15aef77317315698f87acf732d4d63b0"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_resume</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Resume one or more task groups. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task groups to resume</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216task_group_abort8uint32_t">
<span id="task_group_abort__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga648dac279918f6f2d5f717359e3af9d1"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_group_abort</code><span class="sig-paren">(</span>uint32_t <em>groups</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Abort one or more task groups. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">groups</span></code>: Task groups to abort</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215task_mutex_lockP7k_mutex7int32_t">
<span id="task_mutex_lock__k_mutexP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa3759021ab645ac2f9d234161151a1d3"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_mutex_lock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Lock mutex. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine locks mutex <em>mutex</em>. When the mutex is locked by another task, the routine will either wait until it becomes available, or until a specified time limit is reached.</p>
<p>A task is permitted to lock a mutex it has already locked; in such a case, this routine immediately succeeds.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Mutex name. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determine the action to take when the mutex is already locked. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully locked mutex. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting for mutex. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately lock mutex when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217task_mutex_unlockP7k_mutex">
<span id="task_mutex_unlock__k_mutexP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga516028a96317b12e81007ed85bb701bb"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_mutex_unlock</code><span class="sig-paren">(</span><em class="property">struct</em> k_mutex *<em>mutex</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Unlock mutex. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine unlocks mutex <em>mutex</em>. The mutex must already be locked by the requesting task.</p>
<p>The mutex cannot be claimed by another task until it has been unlocked by the requesting task as many times as it was locked by that task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mutex</span></code>: Mutex name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_sem_initP5k_sem">
<span id="nano_sem_init__k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga156704de4718f8eafe634d9f3e0df5f8"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_sem_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a nanokernel semaphore object. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function initializes a nanokernel semaphore object structure. After initialization, the semaphore count is 0.</p>
<p>It can be called from either a fiber or task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_sem_giveP5k_sem">
<span id="nano_sem_give__k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7b07f51e39788501465f8509bd068f43"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_sem_give</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Give a nanokernel semaphore. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine performs a &#8220;give&#8221; operation on a nanokernel sempahore object.</p>
<p>It is also a convenience wrapper for the execution of context-specific APIs and helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_sem_takeP5k_sem7int32_t">
<span id="nano_sem_take__k_semP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga52c41c45064a93b87afab7fc939da026"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">nano_sem_take</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Take a nanokernel semaphore, poll/pend if not available. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine performs a &#8220;give&#8221; operation on a nanokernel sempahore object.</p>
<p>It is also a convenience wrapper for the execution of context-specific APIs and is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>If it is to be called from the context of an ISR, then <em>timeout_in_ticks</em> must be set to TICKS_NONE.</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure. </li>
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Determines the action to take when the semaphore is unavailable. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: When semaphore is available </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_sem_takeP5k_sem7int32_t">
<span id="task_sem_take__k_semP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gae6b8118a1350c61537916d17e925fcbf"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_sem_take</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Take a semaphore or fail. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine takes the semaphore <em>sem</em>. If the semaphore&#8217;s count is zero the routine immediately returns a failure indication.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the semaphore is unavailable. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully took semaphore </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting for semaphore </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately take semaphore when <em>timeout</em> = TICKS_NONE</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214task_sem_resetP5k_sem">
<span id="task_sem_reset__k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga771c394fa0b364f14a1ca7d25773ae53"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_sem_reset</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Reset the semaphore&#8217;s count. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine resets the count of the semaphore <em>sem</em> to zero.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_sem_count_getP5k_sem">
<span id="task_sem_count_get__k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaf18ee86913c24199f6e2284c73c5a743"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_sem_count_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read a semaphore&#8217;s count. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine reads the current count of the semaphore <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Semaphore count. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218nano_sem_count_getP5k_sem">
<span id="nano_sem_count_get__k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3b8ce3eaf77eea322aaf4980abb435d0"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">nano_sem_count_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_sem *<em>sem</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read a nanokernel semaphore&#8217;s count. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine reads the current count of the semaphore <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Semaphore count. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214nano_work_initP6k_work16k_work_handler_t">
<span id="nano_work_init__k_workP.k_work_handler_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaeff16eb125ec44f0e83e2b4e6a7adaf6"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_work_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em>, <a class="reference internal" href="#_CPPv216k_work_handler_t" title="k_work_handler_t">k_work_handler_t</a> <em>handler</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize work item. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">work</span></code>: Work item to initialize </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Handler to process work item</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv225nano_work_submit_to_queueP8k_work_qP6k_work">
<span id="nano_work_submit_to_queue__k_work_qP.k_workP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7769cde75244b3af4c260fe94607bda0"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_work_submit_to_queue</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>wq</em>, <em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a work item to a workqueue. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This procedure schedules a work item to be processed. In the case where the work item has already been submitted and is pending execution, calling this function will result in a no-op. In this case, the work item must not be modified externally (e.g. by the caller of this function), since that could cause the work item to be processed in a corrupted state.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">wq</span></code>: Work queue </li>
<li><code class="docutils literal"><span class="pre">work</span></code>: Work item</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220nano_workqueue_startP8k_work_qPK12fiber_config">
<span id="nano_workqueue_start__k_work_qP.fiber_configCP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaf71f0b3dffc66f0b5eb8a541b111619b"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_workqueue_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_work_q *<em>wq</em>, <em class="property">const</em> <em class="property">struct</em> <a class="reference internal" href="#_CPPv212fiber_config" title="fiber_config">fiber_config</a> *<em>config</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a new workqueue. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine can be called from either fiber or task context.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">wq</span></code>: Work queue </li>
<li><code class="docutils literal"><span class="pre">config</span></code>: Fiber configuration structure</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216nano_work_submitP6k_work">
<span id="nano_work_submit__k_workP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad0796d4de937d35d18d6c91d55f8a8e1"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_work_submit</code><span class="sig-paren">(</span><em class="property">struct</em> k_work *<em>work</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Submit a work item to the system workqueue. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>nano_work_submit_to_queue</p>
<p>When using the system workqueue it is not recommended to block or yield on the handler since its fiber is shared system wide it may cause unexpected behavior. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv222task_event_handler_set8kevent_t16kevent_handler_t">
<span id="task_event_handler_set__kevent_t.kevent_handler_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga22ec23fb4a6332c210084b6e400d14b2"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_event_handler_set</code><span class="sig-paren">(</span>kevent_t <em>legacy_event</em>, kevent_handler_t <em>handler</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set event handler request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine specifies the event handler that runs in the context of the microkernel server fiber when the associated event is signaled. Specifying a non-NULL handler installs a new handler, while specifying a NULL event handler removes the existing event handler.</p>
<p>A new event handler cannot be installed if one already exists for that event. The old handler must be removed first. However, the NULL event handler can be replaced with itself.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">legacy_event</span></code>: Event upon which to register. </li>
<li><code class="docutils literal"><span class="pre">handler</span></code>: Function pointer to handler.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: If an event handler exists or the event number is invalid. </li>
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215task_event_send8kevent_t">
<span id="task_event_send__kevent_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6ee7a883fc18363d7274e7f4973b6057"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_event_send</code><span class="sig-paren">(</span>kevent_t <em>legacy_event</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Signal an event request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine signals the specified event from a task. If an event handler is installed for that event, it will run. If no event handler is installed, any task waiting on the event is released.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">legacy_event</span></code>: Event to signal.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: If the event number is invalid. </li>
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215task_event_recv8kevent_t7int32_t">
<span id="task_event_recv__kevent_t.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga2637fe3ae7a12450b8bd2c3ca02e8024"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_event_recv</code><span class="sig-paren">(</span>kevent_t <em>legacy_event</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Test for an event request with timeout. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine tests an event to see if it has been signaled.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">legacy_event</span></code>: Event to test. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the event has not yet been signaled. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully received signaled event </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting for signaled event </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately receive signaled event when timeout = TICKS_NONE </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_mem_map_allocP10k_mem_slabPPv7int32_t">
<span id="task_mem_map_alloc__k_mem_slabP.voidPP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga493fc00d3b49c6d4f3f9d44caa7044a4"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_mem_map_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>map</em>, void **<em>mptr</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory map block. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine allocates a block from memory map <em>map</em>, and saves the block&#8217;s address in the area indicated by <em>mptr</em>. When no block is available, the routine waits until either one can be allocated, or until the specified time limit is reached.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">map</span></code>: Memory map name. </li>
<li><code class="docutils literal"><span class="pre">mptr</span></code>: Pointer to memory block address area. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the memory map is exhausted. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully allocated memory block. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting for memory block. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately allocate memory block when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217task_mem_map_freeP10k_mem_slabPPv">
<span id="task_mem_map_free__k_mem_slabP.voidPP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga96a67a4a4c5006f27d5687e1fc40bb0c"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_mem_map_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>m</em>, void **<em>p</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return memory slab block. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine returns a block to the specified memory slab.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">m</span></code>: Memory slab name. </li>
<li><code class="docutils literal"><span class="pre">p</span></code>: Memory block address.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv221task_mem_map_used_getP10k_mem_slab">
<span id="task_mem_map_used_get__k_mem_slabP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga73a734aa43142740ecd22809b2e500ad"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_mem_map_used_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_slab *<em>map</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read the number of used blocks in a memory map. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine returns the number of blocks in use for the memory map.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of used blocks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">map</span></code>: Memory map name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219task_mem_pool_allocP11k_mem_blockP10k_mem_pooli7int32_t">
<span id="task_mem_pool_alloc__k_mem_blockP.k_mem_poolP.i.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0f7e1ec95b77f97f6629cb8d7b28e024"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_mem_pool_alloc</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_block *<em>blockptr</em>, <em class="property">struct</em> k_mem_pool *<em>pool_id</em>, int <em>reqsize</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory pool block. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine allocates a block of at least <em>reqsize</em> bytes from memory pool <em>pool_id</em>, and saves its information in block descriptor <em>blockptr</em>. When no such block is available, the routine waits either until one can be allocated, or until the specified time limit is reached.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">blockptr</span></code>: Pointer to block descriptor. </li>
<li><code class="docutils literal"><span class="pre">pool_id</span></code>: Memory pool name. </li>
<li><code class="docutils literal"><span class="pre">reqsize</span></code>: Requested block size, in bytes. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the memory pool is exhausted. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully allocated memory block </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting for memory block </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately allocate memory block when <em>timeout</em> = TICKS_NONE</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_mem_pool_freeP11k_mem_block">
<span id="task_mem_pool_free__k_mem_blockP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga043630e06ec5daa400776a0d475a10e7"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_mem_pool_free</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_block *<em>block</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return memory pool block. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine returns a block to the memory pool from which it was allocated.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">block</span></code>: Pointer to block descriptor.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224task_mem_pool_defragmentP10k_mem_pool">
<span id="task_mem_pool_defragment__k_mem_poolP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7a64928c786ba2162b3dc49597ac64b2"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_mem_pool_defragment</code><span class="sig-paren">(</span><em class="property">struct</em> k_mem_pool *<em>pool</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Defragment memory pool. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine concatenates unused blocks that can be merged in memory pool <em>p</em>.</p>
<p>Doing a full defragmentation of a memory pool before allocating a set of blocks may be more efficient than having the pool do an implicit partial defragmentation each time a block is allocated.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">pool</span></code>: Memory pool name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv211task_malloc8uint32_t">
<span id="task_malloc__uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gae795382d1dbc1b19c919688db13e9891"></span><em class="property">static</em> void *<code class="descclassname"></code><code class="descname">task_malloc</code><span class="sig-paren">(</span>uint32_t <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate memory. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine provides traditional malloc semantics and is a wrapper on top of microkernel pool alloc API. It returns an aligned memory address which points to the start of a memory block of at least <code class="docutils literal"><span class="pre">size</span></code> bytes. This memory comes from heap memory pool, consequently the app should specify its intention to use a heap pool via the HEAP_SIZE keyword in MDEF file, if it uses this API. When not enough free memory is available in the heap pool, it returns NULL</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">size</span></code>: Size of memory requested by the caller.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">address</span></code>: of the block if successful otherwise returns NULL </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv29task_freePv">
<span id="task_free__voidP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad1fa4fb0957990718fa476d58859a1e0"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">task_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Free memory allocated through task_malloc. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine provides traditional free semantics and is intended to free memory allocated using task_malloc API.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>NA </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">ptr</span></code>: pointer to be freed</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_fifo_putP6k_msgqPv7int32_t">
<span id="task_fifo_put__k_msgqP.voidP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gafe18f55039064074150132ac67845d1c"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_fifo_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>queue</em>, void *<em>data</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>FIFO enqueue request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine adds an item to the FIFO queue. When the FIFO is full, the routine will wait either for space to become available, or until the specified time limit is reached.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: FIFO queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Pointer to data to add to queue. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the FIFO is full. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully added item to FIFO. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting to add item to FIFO. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately add item to FIFO when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_fifo_getP6k_msgqPv7int32_t">
<span id="task_fifo_get__k_msgqP.voidP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac3c4d0b7f1df714109f77d292214a79f"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_fifo_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>queue</em>, void *<em>data</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>FIFO dequeue request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine fetches the oldest item from the FIFO queue. When the FIFO is found empty, the routine will wait either until an item is added to the FIFO queue or until the specified time limit is reached.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: FIFO queue. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Pointer to storage location of the FIFO entry. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Affects the action to take when the FIFO is empty. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully fetched item from FIFO. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting to fetch item from FIFO. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately fetch item from FIFO when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215task_fifo_purgeP6k_msgq">
<span id="task_fifo_purge__k_msgqP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga06f91f8109ab924fc6cd4917c5414712"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_fifo_purge</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>queue</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Purge the FIFO of all its entries. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>RC_OK on purge. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: FIFO queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_fifo_size_getP6k_msgq">
<span id="task_fifo_size_get__k_msgqP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga438f3cc7ac9fad99a677a0e99e6b4e51"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_fifo_size_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msgq *<em>queue</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Query the number of FIFO entries. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd># of FIFO entries on query. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">queue</span></code>: FIFO queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_mbox_putP6k_mbox8uint32_tP5k_msg7int32_t">
<span id="task_mbox_put__k_mboxP.uint32_t.k_msgP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6e01c253b1fd3941baa33f0bd69ff443"></span>int <code class="descclassname"></code><code class="descname">task_mbox_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, uint32_t <em>prio</em>, <em class="property">struct</em> k_msg *<em>msg</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a message to a mailbox. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine sends a message to a mailbox and looks for a matching receiver.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>RC_OK Successfully delivered message. </dd>
<dt><strong>Return</strong></dt>
<dd>RC_TIME Timed out while waiting to deliver message. </dd>
<dt><strong>Return</strong></dt>
<dd>RC_FAIL Failed to immediately deliver message when <em>timeout</em> = TICKS_NONE.</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Mailbox. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Priority of data transfer. </li>
<li><code class="docutils literal"><span class="pre">msg</span></code>: Pointer to message to send. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when there is no waiting receiver. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv219task_mbox_block_putP6k_mbox8uint32_tP5k_msgP5k_sem">
<span id="task_mbox_block_put__k_mboxP.uint32_t.k_msgP.k_semP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3623c55abe4d9fab13e5fc026a63da52"></span>void <code class="descclassname"></code><code class="descname">task_mbox_block_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, uint32_t <em>prio</em>, <em class="property">struct</em> k_msg *<em>msg</em>, <em class="property">struct</em> k_sem *<em>sema</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a message asynchronously to a mailbox. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine sends a message to a mailbox and does not wait for a matching receiver. No exchange header is returned to the sender. When the data has been transferred to the receiver, the semaphore signaling is performed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Mailbox to which to send message. </li>
<li><code class="docutils literal"><span class="pre">prio</span></code>: Priority of data transfer. </li>
<li><code class="docutils literal"><span class="pre">msg</span></code>: Pointer to message to send. </li>
<li><code class="docutils literal"><span class="pre">sema</span></code>: Semaphore to signal when transfer is complete.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_mbox_getP6k_mboxP5k_msg7int32_t">
<span id="task_mbox_get__k_mboxP.k_msgP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa040cb8c36e39f1b015b98fd56781e12"></span>int <code class="descclassname"></code><code class="descname">task_mbox_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_mbox *<em>mbox</em>, <em class="property">struct</em> k_msg *<em>msg</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get <strong>struct</strong> <strong>k_msg</strong> message header structure information from. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>RC_OK Successfully received message. </dd>
<dt><strong>Return</strong></dt>
<dd>RC_TIME Timed out while waiting to receive message. </dd>
<dt><strong>Return</strong></dt>
<dd>RC_FAIL Failed to immediately receive message when <em>timeout</em> = TICKS_NONE.</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">mbox</span></code>: Mailbox. </li>
<li><code class="docutils literal"><span class="pre">msg</span></code>: Pointer to message. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when there is no waiting receiver. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218task_mbox_data_getP5k_msg">
<span id="task_mbox_data_get__k_msgP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga95aef70244e512c85fcfe7b01a98f35d"></span>void <code class="descclassname"></code><code class="descname">task_mbox_data_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msg *<em>msg</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get message data. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Call this routine for one of two reasons:<ol class="arabic simple">
<li>To transfer data when the call to <strong>task_mbox_get()</strong> yields an existing field in the <strong>struct</strong> <strong>k_msg</strong> header structure.</li>
<li>To wake up and release a transmitting task currently blocked from calling <strong>task_mbox_put()</strong>.</li>
</ol>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">msg</span></code>: Message from which to get data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv224task_mbox_data_block_getP5k_msgP11k_mem_blockP10k_mem_pool7int32_t">
<span id="task_mbox_data_block_get__k_msgP.k_mem_blockP.k_mem_poolP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga1f5d8255d25074cf1eab35ad19a30b0e"></span>int <code class="descclassname"></code><code class="descname">task_mbox_data_block_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_msg *<em>msg</em>, <em class="property">struct</em> k_mem_block *<em>block</em>, <em class="property">struct</em> k_mem_pool *<em>pool_id</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve message data into a block, with time-limited waiting. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">msg</span></code>: Message from which to get data. </li>
<li><code class="docutils literal"><span class="pre">block</span></code>: Block. </li>
<li><code class="docutils literal"><span class="pre">pool_id</span></code>: Memory pool name. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when no waiting sender exists. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successful retrieval of message data. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting to receive message data. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately receive message data when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_pipe_putP6k_pipePviPi13K_PIPE_OPTION7int32_t">
<span id="task_pipe_put__k_pipeP.voidP.i.iP.K_PIPE_OPTION.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0cf9bcc77c6228cf794fbfd79f02cd44"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_pipe_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>id</em>, void *<em>buffer</em>, int <em>bytes_to_write</em>, int *<em>bytes_written</em>, K_PIPE_OPTION <em>options</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Pipe write request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Attempt to write data from a memory-buffer area to the specified pipe with a timeout option.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">id</span></code>: Pipe ID. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Buffer. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_write</span></code>: Number of bytes to write. </li>
<li><code class="docutils literal"><span class="pre">bytes_written</span></code>: Pointer to number of bytes written. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Pipe options. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the pipe is already full. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully wrote data to pipe. </li>
<li><code class="docutils literal"><span class="pre">RC_ALIGNMENT</span></code>: Data is improperly aligned. </li>
<li><code class="docutils literal"><span class="pre">RC_INCOMPLETE</span></code>: Only some of the data was written to the pipe when <em>options</em> = _ALL_N. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out while waiting to write to pipe. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately write to pipe when <em>timeout</em> = TICKS_NONE</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213task_pipe_getP6k_pipePviPi13K_PIPE_OPTION7int32_t">
<span id="task_pipe_get__k_pipeP.voidP.i.iP.K_PIPE_OPTION.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad28bb2c01ddc4274e08a3cebff9b8b66"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">task_pipe_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_pipe *<em>id</em>, void *<em>buffer</em>, int <em>bytes_to_read</em>, int *<em>bytes_read</em>, K_PIPE_OPTION <em>options</em>, int32_t <em>timeout</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Pipe read request. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Attempt to read data into a memory buffer area from the specified pipe with a timeout option.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">id</span></code>: Pipe ID. </li>
<li><code class="docutils literal"><span class="pre">buffer</span></code>: Buffer. </li>
<li><code class="docutils literal"><span class="pre">bytes_to_read</span></code>: Number of bytes to read. </li>
<li><code class="docutils literal"><span class="pre">bytes_read</span></code>: Pointer to number of bytes read. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Pipe options. </li>
<li><code class="docutils literal"><span class="pre">timeout</span></code>: Determines the action to take when the pipe is already full. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">RC_OK</span></code>: Successfully read data from pipe. </li>
<li><code class="docutils literal"><span class="pre">RC_ALIGNMENT</span></code>: Data is improperly aligned. </li>
<li><code class="docutils literal"><span class="pre">RC_INCOMPLETE</span></code>: Only some of the data was read from the pipe when <em>options</em> = _ALL_N. </li>
<li><code class="docutils literal"><span class="pre">RC_TIME</span></code>: Timed out waiting to read from pipe. </li>
<li><code class="docutils literal"><span class="pre">RC_FAIL</span></code>: Failed to immediately read from pipe when <em>timeout</em> = TICKS_NONE.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214nano_fifo_initP6k_fifo">
<span id="nano_fifo_init__k_fifoP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa9b8713325872a82847dccee7168bb17"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_fifo_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a nanokernel FIFO (fifo) object. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function initializes a nanokernel FIFO (fifo) object structure.</p>
<p>It can be called from either a fiber or task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: FIFO to initialize.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_fifo_putP6k_fifoPv">
<span id="nano_fifo_put__k_fifoP.voidP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad2c2aee541472cff4e76473e042e5111"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_fifo_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, void *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Add an element to the end of a FIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine is a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p>FIFO data items must be aligned on a 4-byte boundary, as the kernel reserves the first 32 bits of each item for use as a pointer to the next data item in the FIFO&#8217;s link list. Each data item added to the FIFO must include and reserve these first 32 bits.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: FIFO on which to interact. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Data to send.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv218nano_fifo_put_listP6k_fifoPvPv">
<span id="nano_fifo_put_list__k_fifoP.voidP.voidP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga78fc39d0421c513b8040797865098b1f"></span>void <code class="descclassname"></code><code class="descname">nano_fifo_put_list</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, void *<em>head</em>, void *<em>tail</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv219nano_fifo_put_slistP6k_fifoP11sys_slist_t">
<span id="nano_fifo_put_slist__k_fifoP.sys_slist_tP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga2a38961db0257e5a3df11ebc4b3fc1e3"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_fifo_put_slist</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, sys_slist_t *<em>list</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>See nano_fifo_put_list for the description of the behaviour.</p>
<p>It takes a pointer to a sys_slist_t object instead of the head and tail of a custom singly-linked list. The sys_slist_t object is invalid afterwards and must be re-initialized via sys_slist_init().</p>
<p>This routine is a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A</dd>
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_list, nano_isr_fifo_put_slist, nano_fiber_fifo_put_slist, nano_task_fifo_put_slist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">fifo</span></code>: FIFO on which to interact. </li>
<li><code class="docutils literal"><span class="pre">list</span></code>: pointer to singly-linked list</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_fifo_getP6k_fifo7int32_t">
<span id="nano_fifo_get__k_fifoP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga92d47cd38a4c3e06ea99e54235bf4eac"></span>void *<code class="descclassname"></code><code class="descname">nano_fifo_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_fifo *<em>fifo</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv214nano_lifo_initP6k_lifo">
<span id="nano_lifo_init__k_lifoP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga24b3e48f7fad78181f7ffdef84090ebe"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_lifo_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a nanokernel linked list LIFO (lifo) object. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function initializes a nanokernel system-level linked list LIFO (lifo) object structure.</p>
<p>It is called from either a fiber or task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: LIFO to initialize.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_lifo_putP6k_lifoPv">
<span id="nano_lifo_put__k_lifoP.voidP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3fc28d964e02c82c0fde1394e8054102"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_lifo_put</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em>, void *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Prepend an element to a LIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine adds an element to the LIFOs&#8217; object head</p>
<p>This routine is a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: LIFO on which to put. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Data to insert.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_lifo_getP6k_lifo7int32_t">
<span id="nano_lifo_get__k_lifoP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga460a03a6c0b303ecdb3af714af8f82ca"></span><em class="property">static</em> void *<code class="descclassname"></code><code class="descname">nano_lifo_get</code><span class="sig-paren">(</span><em class="property">struct</em> k_lifo *<em>lifo</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the first element from a LIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine is a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>If it is to be called from the context of an ISR, then <em>timeout_in_ticks</em> must be set to TICKS_NONE.</dd>
<dt><strong>Return</strong></dt>
<dd>Pointer to head element in the list when available. NULL Otherwise.</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">lifo</span></code>: LIFO on which to receive. </li>
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Affects the action taken should the LIFO be empty. If TICKS_NONE, then return immediately. If TICKS_UNLIMITED, then wait as long as necesssary. Otherwise wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215nano_stack_initP7k_stackP8uint32_t">
<span id="nano_stack_init__k_stackP.uint32_tP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga93b01209afb1833ba535be2c555d3bf6"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_stack_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a nanokernel stack object. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function initializes a nanokernel stack object structure.</p>
<p>It is called from either a fiber or a task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215nano_stack_pushP7k_stack8uint32_t">
<span id="nano_stack_push__k_stackP.uint32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga82598bf0faf47ea9a529aa98475bb7ac"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_stack_push</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t <em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Push data onto a stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine pushes a data item onto a stack object. It is a convenience wrapper for the execution of context-specific APIs and is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Stack on which to interact. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Data to push on stack.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214nano_stack_popP7k_stackP8uint32_t7int32_t">
<span id="nano_stack_pop__k_stackP.uint32_tP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga14720545db7668de5c59bcbbcb0ff968"></span><em class="property">static</em> int <code class="descclassname"></code><code class="descname">nano_stack_pop</code><span class="sig-paren">(</span><em class="property">struct</em> k_stack *<em>stack</em>, uint32_t *<em>data</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Pop data off a stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine pops the first data word from a nanokernel stack object. It is a convenience wrapper for the execution of context-specific APIs and is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p>When the stack is not empty, a data word is popped and copied to the provided address <em>data</em> and a non-zero value is returned. When the routine finds an empty stack, zero is returned.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">stack</span></code>: Stack on which to interact. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: Container for data to pop </li>
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Determines the action to take when the FIFO is empty. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary. Otherwise, wait up to the specified number of ticks before timing out.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">1</span></code>: When data is popped from the stack. </li>
<li><code class="docutils literal"><span class="pre">0</span></code>: Otherwise. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv212sys_tick_getv">
<span id="sys_tick_get__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0cc3c2346a6ef543a9dff14707330477"></span>int64_t <code class="descclassname"></code><code class="descname">sys_tick_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return the current system tick count. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The current system tick count. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215sys_tick_get_32v">
<span id="sys_tick_get_32__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga9634b3e5c51eef5583c8476a80b6222c"></span>uint32_t <code class="descclassname"></code><code class="descname">sys_tick_get_32</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return the lower part of the current system tick count. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The current system tick count. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv214sys_tick_deltaP7int64_t">
<span id="sys_tick_delta__int64_tP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga78622fc9dcfcacb96c025590c3bc8ef9"></span>int64_t <code class="descclassname"></code><code class="descname">sys_tick_delta</code><span class="sig-paren">(</span>int64_t *<em>reftime</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return number of ticks elapsed since a reference time. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The tick count since reference time; undefined for first invocation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Reference time.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv217sys_tick_delta_32P7int64_t">
<span id="sys_tick_delta_32__int64_tP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0a99c503f3d998004ac48efaf67e90a5"></span>uint32_t <code class="descclassname"></code><code class="descname">sys_tick_delta_32</code><span class="sig-paren">(</span>int64_t *<em>reftime</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Return 32-bit number of ticks since a reference time. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A 32-bit tick count since reference time. Undefined for first invocation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">reftime</span></code>: Reference time.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215nano_timer_initP7k_timerPv">
<span id="nano_timer_init__k_timerP.voidP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gadad765d5a0125c0c54315391d20d05e6"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_timer_init</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, void *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a nanokernel timer object. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function initializes a nanokernel timer object structure.</p>
<p>It can be called from either a fiber or task.</p>
<p>The <em>data</em> passed to this function is a pointer to a data structure defined by the user. It contains data that the user wishes to store when initializing the timer and recover when the timer expires. However, the first field of this data structure must be a pointer reserved for the API&#8217;s use that can be overwritten by the API and, as such, should not contain user data.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer. </li>
<li><code class="docutils literal"><span class="pre">data</span></code>: User Data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv216nano_timer_startP7k_timeri">
<span id="nano_timer_start__k_timerP.i"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3f4e3ea23e2ad06b2f91c2e6b2fcf21e"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_timer_start</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, int <em>ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Start a nanokernel timer. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine starts a previously initialized nanokernel timer object. The timer will expire in <em>ticks</em> system clock ticks. It is also a convenience wrapper for the execution of context-specific APIs and is helpful when the the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer. </li>
<li><code class="docutils literal"><span class="pre">ticks</span></code>: Number of ticks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215nano_timer_testP7k_timer7int32_t">
<span id="nano_timer_test__k_timerP.int32_t"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1gab2270834f33e23339a6e7fab522c64cb"></span>void *<code class="descclassname"></code><code class="descname">nano_timer_test</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em>, int32_t <em>timeout_in_ticks</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Wait for a nanokernel timer to expire. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine checks if a previously started nanokernel timer object has expired. It is also a convenience wrapper for the execution of context- specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>If called from an ISR, then <em>timeout_in_ticks</em> must be TICKS_NONE.</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_NONE, TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer. </li>
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Determines the action to take when the timer has not expired. For TICKS_NONE, return immediately. For TICKS_UNLIMITED, wait as long as necessary.</li>
</ul>
</dd>
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">Pointer</span></code>: to timer initialization data. </li>
<li><code class="docutils literal"><span class="pre">NULL</span></code>: If timer not expired.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv215nano_timer_stopP7k_timer">
<span id="nano_timer_stop__k_timerP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3dc3d0e3224bd50acf2e506e28ec2d63"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_timer_stop</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Stop a nanokernel timer. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine stops a previously started nanokernel timer object. It is also a convenience wrapper for the execution of context-specific APIs. It is helpful when the exact execution context is not known. However, it should be avoided when the context is known up-front to avoid unnecessary overhead.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer to stop.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv223nano_timer_ticks_remainP7k_timer">
<span id="nano_timer_ticks_remain__k_timerP"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0520c46a9dabdd9fb42330aa5d98de1e"></span><em class="property">static</em> int32_t <code class="descclassname"></code><code class="descname">nano_timer_ticks_remain</code><span class="sig-paren">(</span><em class="property">struct</em> k_timer *<em>timer</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get nanokernel timer remaining ticks. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function returns the remaining ticks of the previously started nanokernel timer object.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>remaining ticks or 0 if the timer has expired </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer to query</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv213nano_cpu_idlev">
<span id="nano_cpu_idle__void"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8da79485cbcfa7bf3246c0b2fad60f2c"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_cpu_idle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Make the CPU idle. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This function makes the CPU idle until an event wakes it up.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv220nano_cpu_atomic_idlej">
<span id="nano_cpu_atomic_idle__unsigned-i"></span><span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga675e5dbc591c9e7175b56191c75fd053"></span><em class="property">static</em> void <code class="descclassname"></code><code class="descname">nano_cpu_atomic_idle</code><span class="sig-paren">(</span>unsigned int <em>key</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Make the CPU idle in an atomic fashion. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Similar to k_cpu_idle(), but called with interrupts locked if operations must be done atomically before making the CPU idle.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">key</span></code>: Interrupt locking key obtained from irq_lock().</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.DEFINE_TASK">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga49f1066894025478c041e31275008d49"></span><code class="descname">DEFINE_TASK</code><span class="sig-paren">(</span>name, priority, entry, stack_size, groups<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This declares and initializes a private task. The new task can be passed to the microkernel task functions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the task. </li>
<li><code class="docutils literal"><span class="pre">priority</span></code>: Priority of task. </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Entry function. </li>
<li><code class="docutils literal"><span class="pre">stack_size</span></code>: Size of stack (in bytes) </li>
<li><code class="docutils literal"><span class="pre">groups</span></code>: Groups this task belong to. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_fiber_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8d49c57500c27c88dc5066dc5de0db0d"></span><code class="descname">fiber_fiber_start</code></dt>
<dd><p>Initialize and start a fiber from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_start(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_fiber_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gacad1d4755fdd275be66f349a5a1fb66c"></span><code class="descname">task_fiber_start</code></dt>
<dd><p>Initialize and start a fiber from a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_start(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_start_config">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga9d8ab0939c805ad41af717c53f654b0b"></span><code class="descname">fiber_start_config</code><span class="sig-paren">(</span>config, entry, arg1, arg2, options<span class="sig-paren">)</span></dt>
<dd><p>Start a fiber based on a <a class="reference internal" href="#Zephyrd6/dce/structfiber__config"><span class="std std-ref">fiber_config</span></a>. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine can be called from either a fiber or a task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>thread ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">config</span></code>: Pointer to fiber configuration structure </li>
<li><code class="docutils literal"><span class="pre">entry</span></code>: Fiber entry. </li>
<li><code class="docutils literal"><span class="pre">arg1</span></code>: 1st entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">arg2</span></code>: 2nd entry point parameter. </li>
<li><code class="docutils literal"><span class="pre">options</span></code>: Not used currently.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_fiber_start_config">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga998560d69a448d4a6afa541834cc412d"></span><code class="descname">fiber_fiber_start_config</code></dt>
<dd><p>Start a fiber based on a <a class="reference internal" href="#Zephyrd6/dce/structfiber__config"><span class="std std-ref">fiber_config</span></a>, from fiber context. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_start_config(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_start_config() </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_fiber_start_config">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaad6e4b77af72feea7419872e069f6966"></span><code class="descname">task_fiber_start_config</code></dt>
<dd><p>Start a fiber based on a <a class="reference internal" href="#Zephyrd6/dce/structfiber__config"><span class="std std-ref">fiber_config</span></a>, from task context. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_start_config(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_start_config() </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_fiber_delayed_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga4fc1d2d3a7bf47021d4b4af606a8d089"></span><code class="descname">fiber_fiber_delayed_start</code></dt>
<dd><p>Start a fiber while delaying its execution. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_delayed_start(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_delayed_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_fiber_delayed_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaba2bd99ed4498525ccfe86f1b97b2f60"></span><code class="descname">task_fiber_delayed_start</code></dt>
<dd><p>Start a fiber while delaying its execution. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_delayed_start(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_delayed_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_fiber_delayed_start_cancel">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga44f2b5fbbde58a01e26a7e2b1aa784c5"></span><code class="descname">fiber_fiber_delayed_start_cancel</code></dt>
<dd><p>Cancel a delayed fiber start from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_delayed_start_cancel(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_delayed_start_cancel </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_fiber_delayed_start_cancel">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaaf070540abfce9959c0601a627ce82de"></span><code class="descname">task_fiber_delayed_start_cancel</code></dt>
<dd><p>Cancel a delayed fiber start from a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_delayed_start_cancel(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_delayed_start_cancel </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_sleep">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gabdcb0bcbb9524e09b496c6dd7c564969"></span><code class="descname">fiber_sleep</code></dt>
<dd><p>Put the current fiber to sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine puts the currently running fiber to sleep for the number of system ticks passed in the <em>timeout_in_ticks</em> parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Number of system ticks the fiber sleeps.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_sleep">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gacd1c8bfc526377198b4ae37391acf182"></span><code class="descname">task_sleep</code></dt>
<dd><p>Put the task to sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine puts the currently running task to sleep for the number of system ticks passed in the <em>timeout_in_ticks</em> parameter.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>A value of TICKS_UNLIMITED is considered invalid and may result in unexpected behavior.</dd>
<dt><strong>Return</strong></dt>
<dd>N/A</dd>
<dt><strong>See</strong></dt>
<dd>TICKS_UNLIMITED </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timeout_in_ticks</span></code>: Number of system ticks the task sleeps.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_fiber_wakeup">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga940cfccb356fdbc8ea732e80bd1b4f01"></span><code class="descname">isr_fiber_wakeup</code></dt>
<dd><p>Wake the specified fiber from sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_wakeup(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_wakeup </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_fiber_wakeup">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gab426fdd0e5162d5d6124b7b7602fe871"></span><code class="descname">fiber_fiber_wakeup</code></dt>
<dd><p>Wake the specified fiber from sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_wakeup, but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_wakeup </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_fiber_wakeup">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac516a8df874f991059a175598611288b"></span><code class="descname">task_fiber_wakeup</code></dt>
<dd><p>Wake the specified fiber from sleep. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like fiber_wakeup, but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>fiber_wakeup </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_yield">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga58deeccc2a78af90e02bcbab96e5fa0e"></span><code class="descname">task_yield</code></dt>
<dd><p>Yield the CPU to another task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine yields the processor to the next-equal priority runnable task. With task_yield(), the effect of round-robin scheduling is possible. When no task of equal priority is runnable, no task switch occurs, and the calling task resumes execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_task_group_mask_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6b1d057234a7677fe94f5a09fadbbbca"></span><code class="descname">isr_task_group_mask_get</code></dt>
<dd><p>Get task groups for task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>task groups associated with current task </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_task_id_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga59de59153d07acf32088d660208f2088"></span><code class="descname">isr_task_id_get</code></dt>
<dd><p>Get task identifier. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>identifier for current task </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_task_priority_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaffd87529910aa339d80990cfb403214a"></span><code class="descname">isr_task_priority_get</code></dt>
<dd><p>Get task priority. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>priority of current task </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.kmutex_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaef97ed23427851af9197b95e2883d6d4"></span><code class="descname">kmutex_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.DEFINE_MUTEX">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaed7db624fb63ba28b28480fc7281b84c"></span><code class="descname">DEFINE_MUTEX</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Define a private mutex. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Mutex name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_sem">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad8c6da50efae60ad93886836dd52e1ea"></span><code class="descname">nano_sem</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.ksem_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga89f157bbf82410ace3599e6a86f05b7c"></span><code class="descname">ksem_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_isr_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7fb2feebae0e73242dafc1d8a2958e2d"></span><code class="descname">nano_isr_sem_give</code></dt>
<dd><p>Give a nanokernel semaphore (no context switch). </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_give(), but may only be called from an ISR. A fiber pending on the semaphore object will be made ready, but will NOT be scheduled to execute.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_give </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8b0a2da520be27f902f45a24b511a96a"></span><code class="descname">nano_fiber_sem_give</code></dt>
<dd><p>Give a nanokernel semaphore (no context switch). </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_give(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_give </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6238e0f48d00b708ce34919f86653291"></span><code class="descname">nano_task_sem_give</code></dt>
<dd><p>Give a nanokernel semaphore. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_give(), but may only be called from a task. A fiber pending on the semaphore object will be made ready, and will preempt the running task immediately.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_give </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Pointer to a nano_sem structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_sem_take">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga96a312cbfd8d76f7548cec8dcd6b680c"></span><code class="descname">nano_isr_sem_take</code></dt>
<dd><p>Take a nanokernel semaphore, fail if unavailable. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_take(), but must only be called from an ISR with a timeout of TICKS_NONE.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_take </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_sem_take">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga61a2e8d3a0d871ad4ed23f8fb33ce627"></span><code class="descname">nano_fiber_sem_take</code></dt>
<dd><p>Take a nanokernel semaphore, wait or fail if unavailable. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_take(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_take </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_sem_take">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga2132a0db48ea2735ddfa53227a0498b3"></span><code class="descname">nano_task_sem_take</code></dt>
<dd><p>Take a nanokernel semaphore, fail if unavailable. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_sem_take(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_sem_take </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaba01556ef24447e5dbae3ae99fb856f4"></span><code class="descname">isr_sem_give</code></dt>
<dd><p>Give semaphore from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine gives semaphore <em>sem</em> from an ISR, rather than a task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga744a37c64c056f30c586a87fadf5c1e4"></span><code class="descname">fiber_sem_give</code></dt>
<dd><p>Give semaphore from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine gives semaphore <em>sem</em> from a fiber, rather than a task.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_sem_give">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaae95ef01d39cea692e09316f26ea8902"></span><code class="descname">task_sem_give</code></dt>
<dd><p>Give semaphore. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine gives semaphore <em>sem</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">sem</span></code>: Semaphore name.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.DEFINE_SEMAPHORE">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga2c693869b21f3435cc0933cc9da7c260"></span><code class="descname">DEFINE_SEMAPHORE</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel semaphore. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Semaphore name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_work">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaacbc8752f4669224a083a323506e4e9c"></span><code class="descname">nano_work</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.work_handler_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6a9745cdc76186fe7852d3fdb064a34b"></span><code class="descname">work_handler_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_workqueue">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga3479864628a4f78c5f3e0c0b82f262ae"></span><code class="descname">nano_workqueue</code></dt>
<dd><p>A workqueue is a fiber that executes nano_work items that are queued to it. This is useful for drivers which need to schedule execution of code which might sleep from ISR context. The actual fiber identifier is not stored in the structure in order to save space. </p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_delayed_work">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga5d41227655df7c31f52aaa2cbbd7e938"></span><code class="descname">nano_delayed_work</code></dt>
<dd><p>An item which can be scheduled on a nano_workqueue with a delay. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_workqueue_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga82538b8b48a69fa7f84c46480db35f67"></span><code class="descname">nano_task_workqueue_start</code></dt>
<dd><p>Start a new workqueue. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Call this from task context.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_workqueue_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_workqueue_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga94f93e988e6c5a00a2c131711445e84f"></span><code class="descname">nano_fiber_workqueue_start</code></dt>
<dd><p>Start a new workqueue. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Call this from fiber context.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_workqueue_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.isr_event_send">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8cc70e735fd4a0e6f62d46042595dd45"></span><code class="descname">isr_event_send</code></dt>
<dd><p>Signal an event from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine does <em>not</em> validate the specified event number.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">event</span></code>: Event to signal.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.fiber_event_send">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad2090c311695f17f6f7abafed6deddaf"></span><code class="descname">fiber_event_send</code></dt>
<dd><p>Signal an event from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine does <em>not</em> validate the specified event number.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">event</span></code>: Event to signal.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.DEFINE_EVENT">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga713e11b845318f79fe80c21e1b3f9236"></span><code class="descname">DEFINE_EVENT</code><span class="sig-paren">(</span>name, event_handler<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel event. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This declares and initializes a private event. The new event can be passed to the microkernel event functions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the event </li>
<li><code class="docutils literal"><span class="pre">event_handler</span></code>: Function to handle the event (can be NULL) </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.kmemory_map_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaf1834a935d5344f540d573c92cc9a910"></span><code class="descname">kmemory_map_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.DEFINE_MEM_MAP">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga52dcf8e045a916d47ff04d37f5d1ed4d"></span><code class="descname">DEFINE_MEM_MAP</code><span class="sig-paren">(</span>name, map_num_blocks, map_block_size<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel memory map. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Memory map name. </li>
<li><code class="docutils literal"><span class="pre">map_num_blocks</span></code>: Number of blocks. </li>
<li><code class="docutils literal"><span class="pre">map_block_size</span></code>: Size of each block, in bytes. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.k_block">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac122f54692397c787932680ce1f5f66e"></span><code class="descname">k_block</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.kmemory_pool_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6264b2b4b8f317829f778aead2c876b4"></span><code class="descname">kmemory_pool_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.pool_struct">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga257c10cafe506cab4b2470b6318923e4"></span><code class="descname">pool_struct</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.kfifo_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad7238ae1722af09e18ed535283c3c2e3"></span><code class="descname">kfifo_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.DEFINE_FIFO">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaac9bb616d72049bb46e6fbbaab91b33a"></span><code class="descname">DEFINE_FIFO</code><span class="sig-paren">(</span>name, q_depth, q_width<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel FIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This declares and initializes a private FIFO. The new FIFO can be passed to the microkernel FIFO functions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the FIFO. </li>
<li><code class="docutils literal"><span class="pre">q_depth</span></code>: Depth of the FIFO. </li>
<li><code class="docutils literal"><span class="pre">q_width</span></code>: Width of the FIFO. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.kmbox_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa7be1daa99883f2cd1dea758c8da13fa"></span><code class="descname">kmbox_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.DEFINE_MAILBOX">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac116c3fbc379570d7065ae1071c53500"></span><code class="descname">DEFINE_MAILBOX</code><span class="sig-paren">(</span>name<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel mailbox. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine declares and initializes a private mailbox. The new mailbox can be passed to the microkernel mailbox functions.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the mailbox </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.kpipe_t">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga625c41ca898443a276714f50be69ccc5"></span><code class="descname">kpipe_t</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.DEFINE_PIPE">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gacaf902bd37eb05e8465b9edf85f6e4b2"></span><code class="descname">DEFINE_PIPE</code><span class="sig-paren">(</span>name, pipe_buffer_size<span class="sig-paren">)</span></dt>
<dd><p>Define a private microkernel pipe. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">name</span></code>: Name of the pipe. </li>
<li><code class="docutils literal"><span class="pre">pipe_buffer_size</span></code>: Size of the pipe buffer (in bytes) </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fifo">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga01406d7c9b3297ddf194ca56e066a667"></span><code class="descname">nano_fifo</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_isr_fifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaaf2045f8eb29bb830bcff5061724d13d"></span><code class="descname">nano_isr_fifo_put</code></dt>
<dd><p>Add an element to the end of a FIFO from an ISR context. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_fifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gae2c68d790af8a53582cd31bbc21ffca2"></span><code class="descname">nano_fiber_fifo_put</code></dt>
<dd><p>Add an element to the end of a FIFO from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_fifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga98f25dd9984f6fdd1e5405a93e26c338"></span><code class="descname">nano_task_fifo_put</code></dt>
<dd><p>Add an element to the end of a FIFO. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_fifo_put_list">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga166553a2c47d82f68ff0cc86bbaf3ab2"></span><code class="descname">nano_isr_fifo_put_list</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put_list(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_list </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_fifo_put_list">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga14033be2e2948b46c4f9e0d44fe7cb62"></span><code class="descname">nano_fiber_fifo_put_list</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put_list(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_list </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_fifo_put_list">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga7421fa7adfb73cdf802dd282c52c6654"></span><code class="descname">nano_task_fifo_put_list</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put_list(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_list </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_fifo_put_slist">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gac96173e61cc9fd64d08aa0594a9860de"></span><code class="descname">nano_isr_fifo_put_slist</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put_slist(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_slist </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_fifo_put_slist">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaa28cd82e84fde6a3b1706768ebed7661"></span><code class="descname">nano_fiber_fifo_put_slist</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_put_slist(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_slist </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_fifo_put_slist">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gae18b7309e923ac2858680c004f885d63"></span><code class="descname">nano_task_fifo_put_slist</code></dt>
<dd><p>Atomically add a list of elements to the end of a FIFO from a fiber. </p>
<p>Like nano_fifo_put_slist(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_put_slist </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_fifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad0eff0ec920d73d74de9ee0adb1d7c1b"></span><code class="descname">nano_isr_fifo_get</code></dt>
<dd><p>Get an element from the head of a FIFO from an ISR context. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_get(), but may only be called from an ISR with a timeout of TICKS_NONE.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_fifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga06512cef688c5b5b10bc478b368d4ae7"></span><code class="descname">nano_fiber_fifo_get</code></dt>
<dd><p>Get an element from the head of a FIFO from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_get(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_fifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gafd45c2b4e5cc8ce13ef9c01907120bbe"></span><code class="descname">nano_task_fifo_get</code></dt>
<dd><p>Get an element from a FIFO&#8217;s head that comes from a task, poll if empty. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_fifo_get(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_fifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_lifo">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga700609cf18bc91421def6b99b11fe2e8"></span><code class="descname">nano_lifo</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_isr_lifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga986d5a83a3f2517242cf3050e9efe68a"></span><code class="descname">nano_isr_lifo_put</code></dt>
<dd><p>Prepend an element to a LIFO without a context switch. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_put(), but may only be called from an ISR. A fiber pending on the LIFO object will be made ready, but will NOT be scheduled to execute.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_lifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga77c6c3b36f82b252698e6740fa35b7e6"></span><code class="descname">nano_fiber_lifo_put</code></dt>
<dd><p>Prepend an element to a LIFO without a context switch. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_put(), but may only be called from a fiber. A fiber pending on the LIFO object will be made ready, but will NOT be scheduled to execute.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_lifo_put">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga63376630938582156c46019577a7834c"></span><code class="descname">nano_task_lifo_put</code></dt>
<dd><p>Add an element to the LIFO&#8217;s linked list head. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_put(), but may only be called from a task. A fiber pending on the LIFO object will be made ready, and will preempty the running task immediately.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_put </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_lifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga990d53be720534b35d44c4ed14dd6896"></span><code class="descname">nano_isr_lifo_get</code></dt>
<dd><p>Remove the first element from a LIFO linked list. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_get(), but may only be called from an ISR with a timeout of TICKS_NONE.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_lifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga4824234ed1e932734c6299fae65e2488"></span><code class="descname">nano_fiber_lifo_get</code></dt>
<dd><p>Prepend an element to a LIFO without a context switch. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_get(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_lifo_get">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gaf42b8d0b32dca27e6f2de8fc3fcfb72c"></span><code class="descname">nano_task_lifo_get</code></dt>
<dd><p>Remove the first element from a LIFO linked list. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_lifo_get(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_lifo_get </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_stack">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga44bc610682ce0e1435201ad5d9c573e2"></span><code class="descname">nano_stack</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_isr_stack_push">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga915f1693722f272fde3f9c21ccd6866e"></span><code class="descname">nano_isr_stack_push</code></dt>
<dd><p>Push data onto a stack (no context switch). </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_push(), but may only be called from an ISR. A fiber that pends on the stack object becomes ready but will NOT be scheduled to execute.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_push </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_stack_push">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gab2e0b01709255f5ef23cb4d4c0c5644e"></span><code class="descname">nano_fiber_stack_push</code></dt>
<dd><p>Push data onto a stack (no context switch). </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_push(), but may only be called from a fiber. A fiber that pends on the stack object becomes ready but will NOT be scheduled to execute.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_push </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_stack_push">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gab8d0fc9b4f8839b132fb52c2873adf1b"></span><code class="descname">nano_task_stack_push</code></dt>
<dd><p>Push data onto a nanokernel stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_push(), but may only be called from a task. A fiber that pends on the stack object becomes ready and preempts the running task immediately.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_push </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_stack_pop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8b9c6d3ad53eb817447b446166488187"></span><code class="descname">nano_isr_stack_pop</code></dt>
<dd><p>Pop data from a nanokernel stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_pop(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_pop </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_stack_pop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8c86a7daa458595cd7882a25389f4617"></span><code class="descname">nano_fiber_stack_pop</code></dt>
<dd><p>Pop data from a nanokernel stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_pop(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_pop </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_stack_pop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga1f1d752f0c45adee3c0a4f88aebec92d"></span><code class="descname">nano_task_stack_pop</code></dt>
<dd><p>Pop data from a nanokernel stack. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_stack_pop(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_stack_pop </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.sys_cycle_get_32">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga0438f8fb386ac729d6bab0df990fb71c"></span><code class="descname">sys_cycle_get_32</code></dt>
<dd><p>Return a time stamp in high-resolution format. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine reads the counter register on the processor&#8217;s high precision timer device. This counter register increments at a relatively high rate (e.g. 20 MHz), and is thus considered a high-resolution timer. This is in contrast to sys_tick_get_32() which returns the value of the system ticks variable.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The current high-precision clock value. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_timer">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga931cfb615fd9a0b1bc9dc0d69e217b97"></span><code class="descname">nano_timer</code></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.nano_isr_timer_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga11b48c12bc8de7e01678c9e9120df54a"></span><code class="descname">nano_isr_timer_start</code></dt>
<dd><p>Start a nanokernel timer from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_start(), but may only be called from an ISR with a timeout of TICKS_NONE.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_timer_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga6fd82e8d2322fc8e9502ef2e40c0aa34"></span><code class="descname">nano_fiber_timer_start</code></dt>
<dd><p>Start a nanokernel timer from a fiber. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_start(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_timer_start">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga2e34f85300c7f841392cd312e9c6158b"></span><code class="descname">nano_task_timer_start</code></dt>
<dd><p>Start a nanokernel timer from a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_start(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_start </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_timer_test">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga9d1670257cb1043f2211525128f34047"></span><code class="descname">nano_isr_timer_test</code></dt>
<dd><p>Make the current ISR check for a timer expiry. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_test(), but may only be called from an ISR with a timeout of TICKS_NONE.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_test </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_timer_test">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8426fcda3747e00903bc70470f324dde"></span><code class="descname">nano_fiber_timer_test</code></dt>
<dd><p>Make the current fiber check for a timer expiry. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_test(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_test </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_timer_test">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga8e1998874f60ae249689372d953f41bd"></span><code class="descname">nano_task_timer_test</code></dt>
<dd><p>Make the current task check for a timer expiry. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_test(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_test </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.task_timer_stop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gad1c4012eeb90b0d4f5202c8ced76c9ed"></span><code class="descname">task_timer_stop</code></dt>
<dd><p>Stop a timer. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>This routine stops the specified timer. If the timer period has already elapsed, the call has no effect.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>N/A </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">timer</span></code>: Timer to stop.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_isr_timer_stop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga037f64e0574c2bbe6de45109c2d20734"></span><code class="descname">nano_isr_timer_stop</code></dt>
<dd><p>Stop a nanokernel timer from an ISR. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_stop(), but may only be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_stop </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_fiber_timer_stop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1ga31a08869d5338775e326ee77a7e99683"></span><code class="descname">nano_fiber_timer_stop</code></dt>
<dd><p>Stop a nanokernel timer. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_stop(), but may only be called from a fiber.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_stop </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.nano_task_timer_stop">
<span class="target" id="Zephyrd8/dad/group__legacy__apis_1gae08c499f709f7e6fe43b1ec9e498bcf6"></span><code class="descname">nano_task_timer_stop</code></dt>
<dd><p>Stop a nanokernel timer from a task. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Like nano_timer_stop(), but may only be called from a task.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd>nano_timer_stop </dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv212fiber_config">
<span id="fiber_config"></span><span class="target" id="Zephyrd6/dce/structfiber__config"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">fiber_config</code><br /></dt>
<dd><em>#include &lt;legacy.h&gt;</em><p>Fiber configuration structure. </p>
<p><strong> Legacy API: Will be deprecated in Zephyr 1.9 </strong> </p>
<p>Parameters such as stack size and fiber priority are often user configurable. This structure makes it simple to specify such a configuration. </p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="Zephyrd7/d5d/unionk__msg_8extra"></span><em class="property">union </em></dt>
<dd><p>internal use only </p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt>
<span class="target" id="Zephyrd7/d5d/unionk__msg_8extra_1a84a0f3455dcca894ace136be62efa292"></span><code class="descname"></code></dt>
<dd><p>for 2-steps data transfer operation </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="Zephyrd7/d5d/unionk__msg_8extra_1a089ac4682a780fd36a19a6279c977758"></span><code class="descname"></code></dt>
<dd><p>semaphore to signal when asynchr. call </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="device.html" class="btn btn-neutral float-right" title="Device Driver Interface" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="api.html" class="btn btn-neutral" title="API Documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Intel Corporation, Wind River Systems, Inc.
      Last updated on Jan 26, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.6.99',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>